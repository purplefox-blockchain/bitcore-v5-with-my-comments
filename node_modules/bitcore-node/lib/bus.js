'use strict';

var events = require('events');
var util = require('util');

var index = require('.');
var log = index.log;

/**
 * The bus represents a connection to node, decoupled from the transport layer, that can
 * listen and subscribe to any events that are exposed by available services. Services
 * can expose events that can be subscribed to by implementing a `getPublishEvents` method.
 * @param {Object} params
 * @param {Node} params.node - A reference to the node
 */
//the constructor expects two parameters: node, remoteAddress
function Bus(params) {
  events.EventEmitter.call(this);
  this.node = params.node;
  this.remoteAddress = params.remoteAddress;
}

util.inherits(Bus, events.EventEmitter);

/**
 * This function will find the service that exposes the event by name and
 * call the associated subscribe method with the arguments excluding the
 * first argument of this function.
 * @param {String} name - The name of the event such as p2p/block
 */
//many service has a bus instance (most named it _bus)
Bus.prototype.subscribe = function(name) {
  log.info('YCM: Bus.subscribe '+name);

  //for every subscribe call from subscribers (e.g. this._bus.subscribe('p2p/block'); from header),
  //we dynamically reconstruct the 'event universe' (seems there is room for optimization)
  var events = [];

  //first we concat all published events from all services
  //this is the universe of events. what does each event look like?
  //take p2p module for example, as we know header module will subscribe for p2p/block event
  //line 125+ defines getPublishEvents() and the data structure of the 'events'
  //   P2P.prototype.getPublishEvents = function() {
  //       return [
  //           {...},
  //           {
  //               name: 'p2p/block',
  //               scope: this, //the instance of the publisher
  //               subscribe: this.subscribe.bind(this, 'block'),
  //               unsubscribe: this.unsubscribe.bind(this, 'block')
  //           },
  //           {...}
  //       ];
  //   };
  for(var i in this.node.services) {
    var service = this.node.services[i];
    events = events.concat(service.getPublishEvents());
  }

  for (var j = 0; j < events.length; j++) {
    var event = events[j];
    //the Array.prototype.slice.call(arguments) construct a new array, the subsequent .slice(1) cut the first element in the new array
    var params = Array.prototype.slice.call(arguments).slice(1);
    //unshift() insert the argument (in this case 'this' bus) to the front of 'params' array
    params.unshift(this);
    //the last two lines, my understanding is, the event name is consumed and rest of the arguments (there aren't any however) are left and passed on
    //on runtime, arguments is [ 'p2p/block' ], params is [ SingleBusObject ]

    //note that i find it a little bit confusing that the code construct params out of the passed-in argument. it seems 'name' not used at all after the if condition()

    if (name === event.name) {

      //at the high level,
      //so far since we are inside if(), we found the matching event, after searching the array of 'published' events from all services of the node
      //we know who is the publisher of the event, using event.scope reference (for 'p2p/block' event, its event.scope is a p2p object)
      //at the end of this func, the control flow goes back to the event publisher's .subscribe() function with two arguments (eventNameInString, aBusInstanceRepresentingSubscriber)
      //where the bus of the subscriber get pushed to the publisher's subscriptions map : publisherInstance.subscriptions[name].push(busOfSubscriber);
      //in other words, subscriber by calling bus.js subscribe(), it links the subscriber itself with publisher
      //continue to read from P2P.prototype.subscribe = function(name, emitter) {...} to see what happen next after this function being called

      //at the low level,
      //some javascript syntax
      //apply ==> function.apply(thisArg, [argsArray]) => return value: the result of function.apply(thisArg, [argsArray]) is the result of calling the function with the specified this value and arguments.
      //bind ==> function.bind(thisArg[, arg1[, arg2[, ...]]]) => arg1 arg2 are arguments to ***prepend*** to arguments provided to the bound function when invoking the target function; return value: A copy of the given function with the specified this value and initial arguments.
      //apply() return a result of execution, bind() return a function copy, the difference is very significant!

      //learn how bind()'s arg1 arg2 prepend works
      //function Point(x, y) { this.x = x; this.y = y; }
      //Point.prototype.toString = function() { return this.x + ',' + this.y; };
      //var p = new Point(1, 2);
      //p.toString();   // '1,2'
      //var emptyObj = {};
      //var YAxisPoint = Point.bind(emptyObj, 0); //0 is the fixed x-axis, get prepended to the runtime arguments when the target function YAxisPoint is invoked
      //var aCompletePoint = new YAxisPoint(5);   //we only need to supply 5 for y axis
      //the Point constructor is called with arguments (0,5)
      //aCompletePoint.toString();  // we get '0,5'

      //we look at the code
      //event.subscribe.apply(event.scope, params)
      // => FFF.apply(event.scope, params) where FFF is a new function returned by this.subscribe.bind(this, 'block') according to P2P.prototype.getPublishEvents
      //according to the bind prepend feature,
      //FFF is a function that is very similar to subscribe function of this instance, but FFF will prepend a argument 'block' to whatever argument supplied on runtime and feed the new arguments to the target instance's subscribe() function
      //bear this 'runtime-argument-manipulation' in mind, we continue to look at apply() function
      //note that (event.scope) is the 'this' to be bound to this.subscribe(), on runtime it is the p2p
      //so our this instance refers to event.scope , which is p2p instance now
      // => FFF.apply(p2p, params)
      // => (lets expand FFF or apply FFF using p2p)
      // => p2p.manipulatedSubscribe(params)  //manipulated subscribe function that cloned/twisted by bind()
      // => p2p.subscribe('block',params) //equivalent to its original subscribe function counter part
      //note that params on runtime is an bus instance, which represent the subscriber of this event
      // => p2p.subscribe('block', busInstanceWhichRepresentTheSubscriberAndRelatedData )
      //this correspond to the parameter in P2P.prototype.subscribe = function(name, emitter)
      //where name is 'block', emitter is 'busRepresentTheSubscirber'

      //The call() method takes arguments separately. The apply() method takes arguments as an array.
      //apply() syntax: function.apply(thisArg, [argsArray])
      //so this line will invoke the subscribe function of the publisher (i.e. 'event.scope'), passing over the 'params' which is an array of Bus instance (length=1 i.e. only one bus)
      //the actual values of event.scope may be P2P, header. look for code liks P2P.prototype.subscribe = function(){...} and HeaderService.prototype.subscribe = function(){...}
      //those functions will be applied with params.
      //assume event.scope = p2p,
      //this code will do
      // - p2p.subscribe (see code P2P.prototype.subscribe = function(name, emitter) {...} )
      event.subscribe.apply(event.scope, params);
    }
  }
};

/**
 * The inverse of the subscribe method.
 * @param {String} name - The name of the event
 */
Bus.prototype.unsubscribe = function(name) {
  var events = [];

  for(var i in this.node.services) {
    var service = this.node.services[i];
    events = events.concat(service.getPublishEvents());
  }

  for (var j = 0; j < events.length; j++) {
    var event = events[j];
    var params = Array.prototype.slice.call(arguments).slice(1);
    params.unshift(this);
    if (name === event.name) {
      event.unsubscribe.apply(event.scope, params);
    }
  }
};

/**
 * This function will unsubscribe all events.
 */
Bus.prototype.close = function() {
  var events = [];

  for(var i in this.node.services) {
    var service = this.node.services[i];
    events = events.concat(service.getPublishEvents());
  }

  // Unsubscribe from all events
  for (var j = 0; j < events.length; j++) {
    var event = events[j];
    event.unsubscribe.call(event.scope, this);
  }
};

module.exports = Bus;

