'use strict';

var async = require('async');
var BaseService = require('../../service');
var inherits = require('util').inherits;
var Encoding = require('./encoding');
var index = require('../../');
var log = index.log;
var utils = require('../../utils');
var assert = require('assert');
var constants = require('../../constants');
var bcoin = require('bcoin');
var _ = require('lodash');
var LRU = require('lru-cache');
var util = require('util');

var BlockService = function(options) {

  BaseService.call(this, options);

  this._subscriptions = {};
  this._subscriptions.block = [];

  this._tip = null;
  //we will use these services of the same node instance
  this._db = this.node.services.db;
  this._p2p = this.node.services.p2p;
  this._header = this.node.services.header;
  this._timestamp = this.node.services.timestamp;
  this._mempool = this.node.services.mempool;

  this.GENESIS_HASH = constants.BITCOIN_GENESIS_HASH[this.node.network];
  this._initialSync = false;
  this._processingBlock = false;

  this._blocksInQueue = 0;
  this._recentBlockHashesCount = options.recentBlockHashesCount || 144; // block service won't reorg past this point
  this._recentBlockHashes = new LRU(this._recentBlockHashesCount);
  this._readAheadBlockCount = options.readAheadBlockCount || 2; // this is the number of blocks to direct the p2p service to read aheead
  this._pauseSync = options.pause;
  this._reorgToBlock = options.reorgToBlock;
};

inherits(BlockService, BaseService);

BlockService.dependencies = [ 'timestamp', 'p2p', 'db', 'header', 'mempool' ];

BlockService.prototype.subscribe = function(name, emitter) {
  this._subscriptions[name].push(emitter);
  log.info(emitter.remoteAddress, 'subscribe:', 'block/' + name, 'total:', this._subscriptions[name].length);
};

BlockService.prototype.unsubscribe = function(name, emitter) {
  var index = this._subscriptions[name].indexOf(emitter);
  if (index > -1) {
    this._subscriptions[name].splice(index, 1);
  }
  log.info(emitter.remoteAddress, 'unsubscribe:', 'block/' + name, 'total:', this._subscriptions[name].length);
};

BlockService.prototype.getPublishEvents = function() {
  return [
    {
      name: 'block/block',
      scope: this,
      subscribe: this.subscribe.bind(this, 'block'),
      unsubscribe: this.unsubscribe.bind(this, 'block')
    }
  ];
};

BlockService.prototype.getAPIMethods = function() {
  var methods = [
    ['getInfo', this, this.getInfo, 0],
    ['getBlock', this, this.getBlock, 1],
    ['getRawBlock', this, this.getRawBlock, 1],
    ['getBlockOverview', this, this.getBlockOverview, 1],
    ['getBestBlockHash', this, this.getBestBlockHash, 0],
    ['syncPercentage', this, this.syncPercentage, 0],
    ['isSynced', this, this.isSynced, 0]
  ];
  return methods;
};

BlockService.prototype.getInfo = function(callback) {
  var self = this;
  callback(null, {
    blocks: self.getTip().height,
    connections: self._p2p.getNumberOfPeers(),
    timeoffset: 0,
    proxy: '',
    testnet: self.node.network === 'livenet' ? false: true,
    errors: '',
    network: self.node.network,
    relayFee: 0,
    version: 'bitcore-1.1.2',
    protocolversion: 700001,
    difficulty: self._header.getCurrentDifficulty()
  });
};

BlockService.prototype.isSynced = function(callback) {
  callback(null,  !this._initialSync);
};

BlockService.prototype.getBestBlockHash = function(callback) {
  var hash = this._header.getLastHeader().hash;
  callback(null, hash);
};

BlockService.prototype.getTip = function() {
  return this._tip;
};

BlockService.prototype.getBlock = function(arg, callback) {

  var self = this;
  //'hash' in the 2nd callback param is the result returned by _getHash()
  self._getHash(arg, function(err, hash) {

    if (err) {
      return callback(err);
    }

    if (!hash) {
      return callback();
    }

    self._getBlock(hash, callback);
  });

};

//first we _getBlock(hash) -> returned result in 'block'
//second, we getBlockHeader(hash) -> returned result in 'header'
//we then construct a new data structure blockOverview by combining some key info from 'header' and 'block'
//we callback with blockOverview
BlockService.prototype.getBlockOverview = function(hash, callback) {

  var self = this;

  self._getBlock(hash, function(err, block) {

    if (err) {
      return callback(err);
    }

    if (!block) {
      return callback();
    }

    self._header.getBlockHeader(hash, function(err, header) {

      if (err) {
        return callback(err);
      }

      var target = bcoin.mining.common.getTarget(header.bits);
      var difficulty = bcoin.mining.common.getDifficulty(target);
      var txids = block.txs.map(function(tx) {
        return tx.txid();
      });

      var blockOverview = {
        hash: block.rhash(),
        version: block.version,
        confirmations: self.getTip().height - header.height + 1,
        height: header.height,
        chainWork: header.chainwork,
        prevHash: header.prevHash,
        nextHash: header.nextHash,
        merkleRoot: header.merkleRoot,
        time: block.ts,
        medianTime: null,
        nonce: header.nonce,
        bits: header.bits,
        difficulty: difficulty,
        txids: txids
      };

      callback(null, blockOverview);
    });
  });

};

BlockService.prototype.getRawBlock = function(hash, callback) {
  this.getBlock(hash, function(err, block) {
    if(err) {
      return callback(err);
    }
    if (!block) {
      return callback();
    }
    callback(null, block.toRaw().toString('hex'));
  });
};

BlockService.prototype._checkTip = function(callback) {

  var self = this;

  log.info('Block Service: checking the saved tip...');

  //my tip height's header
  self._header.getBlockHeader(self._tip.height, function(err, header) {

    if (err) {
      return callback(err);
    }

    //getBlockHeader(_tip.height) may return null, i.e. header=null
    //i think that means my current tip is discarded by the network
    //if header is null, we use last header from _header() instead
    header = header || self._header.getLastHeader();

    if (header.hash === self._tip.hash && !self._reorgToBlock) {
      //if we see this message, means our tip is the right one
      log.info('Block Service: saved tip is good to go.');
      //then we return
      return callback();
    }

    //otherwise we reorg (though i know little about reorg)
    self._handleReorg(callback);

  });
};

BlockService.prototype._resetTip = function(callback) {
  var self = this;

  //if we failed sanity check at the beginning
  //we will set the flag to false and start resetting tip

  if (!self._tipResetNeeded) {
    return callback();
  }

  self._tipResetNeeded = false;
  var bar = new utils.IndeterminateProgressBar();

  log.warn('Block Service: resetting tip due to a non-existent tip block...');

  var block;
  var header = self._header.getLastHeader();
  var height = header.height;

  self._header.getAllHeaders(function(err, headers) {

    if (err || !headers) {
      return callback(err || new Error('headers required'));
    }

    log.info('Block Service: retrieved all the headers for lookups.');

    async.until(function() {

      if (process.stdout.isTTY) {
        bar.tick();
      }

      return block;

    }, function(next) {

      self._getBlock(header.hash, function(err, _block) {

        if (err) {
          return callback(err);
        }

	if (!_block) {
          log.debug('Block Service: block: ' + header.hash + ' was not found, proceeding to older blocks.');
	}

        block = _block;
        header = headers.getIndex(--height);
        assert(header, 'Header not found for reset.');

        if (!block) {
          log.debug('Block Service: trying block: ' + header.hash);
        }

        next();

      });

    }, function(err) {

      if (err || !block) {
        return callback(err ||
          new Error('Block Service: none of the blocks from the headers match what is already indexed in the block service.'));
      }

      self._setTip({ hash: block.rhash(), height: height + 1 }, callback);

    });

  });
};

BlockService.prototype._performSanityCheck = function(tip, callback) {

  var self = this;

  if (tip.height === 0) {
    return callback(null, tip);
  }

  // is our tip saved in our database? If not, then find the latest block that is in
  // in our database and set the tip to that
  self._getBlock(tip.hash, function(err, block) {
    if (err) {
      return callback(err);
    }
    if (block) {
      return callback(null, tip);
    }
    return callback(null, false);
  });
};

BlockService.prototype.start = function(callback) {

  var self = this;

  //my understanding is , find the service tip, check it,
  //if checking is ok, save it to _tip, and save it to db
  //why save?? are we saving something that we just loaded from db?
  //seems that if everything goes fine, we are indeed save the same data that we just loaded using getServiceTip
  async.waterfall([
    //what is this for?
    function(next) {
      self._db.getPrefix(self.name, next);
    },
    //what is this for?
    function(prefix, next) {
      self._prefix = prefix;
      self._encoding = new Encoding(self._prefix);
      self._db.getServiceTip('block', next);
    }
  ], function(err, tip) {

    if(err) {
      return callback(err);
    }

    //we perform sanity check
    //if the check is passed, the tip in the callback function(err,tip) is the same tip that we pass in
    //otherwise we will have that returned tip as false
    self._performSanityCheck(tip, function(err, tip) {

      if (err) {
        return callback(err);
      }

      log.info('block service completed its sanity check on tip');
      //after sanity check, this callback func is the last part of start()

      //we register our block processor, we open a bus
      self._blockProcessor = async.queue(self._onBlock.bind(self));
      self._bus = self.node.openBus({remoteAddress: 'localhost-block'});

      //the returned tip is false, means we failed sanitycheck, we set resetNeeded flag to true
      //so that later when our onHeaders() is called, tip will get automatically reset then
      if (!tip) {
        self._tipResetNeeded = true;
        return callback();
      }

      self._header.on('reorg', function() {
        self._reorging = true;
      });

      self._header.on('reorg complete', function() {
        self._reorging = false;
      });

      //set it to _tip and save to db
      self._setTip(tip, function(err) {

        if (err) {
          return callback(err);
        }

        //after sanity check, after setTip, after everything, we load recent 144 blocks
        self._loadRecentBlockHashes(callback);

      });
    });

  });

};

//based on all the blocks we have, load the most recent 144 blocks, save them to _recentBlockHashes
//this is done when block service is started by the node
BlockService.prototype._loadRecentBlockHashes = function(callback) {

  var self = this;
  var hash = self._tip.hash;

  //unless _tip.height is less than 144 (that means our db is empty, only has a few blocks),
  //we will get the highest 144 blocks starting from the tip, in reverse order
  var times = Math.min(self._tip.height, self._recentBlockHashesCount);

  //aysnc.timesSeries syntax: call func() x times, each at a time
  async.timesSeries(times, function(n, next) {

    self.getBlock(hash, function(err, block) {

      if (err || !block) {
        return callback(err || new Error('Block Service: attempted to retrieve block: ' + hash +
          ' but was not in the index.'));
      }

      //my understanding : reverse hash in little endian
      var prevHash = bcoin.util.revHex(block.prevBlock);
      self._recentBlockHashes.set(hash, prevHash);
      hash = prevHash;
      next();

    });

  }, function(err) {

    if (err) {
      return callback(err);
    }

    assert(self._recentBlockHashes.length === times, 'Block Service: did not load enough recent block hashes from the index.');
    log.info('Block Service: loaded: ' + self._recentBlockHashes.length + ' hashes from the index.');
    callback();

  });

};

BlockService.prototype.stop = function(callback) {
  setImmediate(callback);
};

BlockService.prototype._getTimeSinceLastBlock = function(callback) {

  var self = this;

  self._header.getBlockHeader(Math.max(self._tip.height - 1, 0), function(err, header) {

    if(err || !header) {
      return callback(err || new Error('Block Service: we should have a header in order to get time since last block.'));
    }

    async.map([ self._tip.hash, header.hash ], function(hash, next) {
      self._timestamp.getTimestamp(hash, next);
    }, function(err, times) {
      if (err) {
        return callback(err);
      }
      return callback(null, utils.convertMillisecondsToHumanReadable((times[0] * 1000) - (times[1] * 1000)));
    });
  });

};

BlockService.prototype._queueBlock = function(block) {

  var self = this;

  self._blocksInQueue++;

  self._blockProcessor.push(block, function(err) {

    if (err) {
      return self._handleError(err);
    }

    self._logSynced(block.rhash());
    self._blocksInQueue--;

  });

};

BlockService.prototype._syncPercentage = function() {
  var height = this._header.getLastHeader().height;
  var ratio = this._tip.height/height;
  return (ratio*100).toFixed(2);
};

BlockService.prototype.syncPercentage = function(callback) {
  callback(null, this._syncPercentage());
};

//my understanding is, we process block by block according to the chain's order
//if the new block's prevBlock is not our current's tip, something is wrong,
//then we say we detected a reorg
BlockService.prototype._detectReorg  = function(block) {
  // a block that is regarded as a "reorging block" could be one that was
  // mined using a previously-orphaned block as its previous block.
  // in this case, we want to completely ignore this block and move on
  return bcoin.util.revHex(block.prevBlock) !== this._tip.hash;
};

//given block hash, we encode it and use it as key to get block data from db
//decode what we have and call the callback with the decoded block
BlockService.prototype._getBlock = function(hash, callback) {

  var self = this;

  this._db.get(this._encoding.encodeBlockKey(hash), function(err, data) {

    if(err) {
      return callback(err);
    }

    if (!data) {
      return callback();
    }

    var block = self._encoding.decodeBlockValue(data);
    callback(null, block);

  });
};

BlockService.prototype._getHash = function(blockArg, callback) {

  if (utils.isHeight(blockArg)) {

    //call header to do the job, but from header's code, we know
    //_header.GetBlockHeader also accept hash as argument.
    //when the callback function is called, 'header' (2nd arg) is ready
    this._header.getBlockHeader(blockArg, function(err, header) {

      if(err) {
        return callback(err);
      }

      if (!header) {
        return callback();
      }

      //we then notify the caller of _getHash() our result (which is header.hash)
      //callback syntax: callback(errorIfAny, resultData)
      callback(null, header.hash);
    });

  }

  return callback(null, blockArg);

};

BlockService.prototype.onReorg = function(args, callback) {

  var self = this;

  var block = args[1][0];

  var removalOps = [{
    type: 'del',
    key: self._encoding.encodeBlockKey(block.rhash()),
  }];

  setImmediate(function() {
    callback(null, removalOps);
  });
};

BlockService.prototype._onReorg = function(commonAncestorHash, block, callback) {

  var self = this;
  var services = self.node.services;

  async.mapSeries(services, function(service, next) {

    if(!service.onReorg) {
      log.debug('Block Service: skipping reorg for: ' + service.name + ' service.');
      return setImmediate(next);
    }

    log.info('Block Service: Reorging: ' + service.name + ' service.');
    service.onReorg.call(service, [commonAncestorHash, [block]], next);

  }, callback);

};

BlockService.prototype._removeAllSubscriptions = function() {
  this._bus.unsubscribe('p2p/block');
  this._bus.removeAllListeners();
  this.removeAllListeners(); // will remove listeners for 'next block' and 'synced'
  this._subscribedBlock = false;
  if (this._reportInterval) {
    clearInterval(this._reportInterval);
  }
  if (this._getBlocksTimer) {
    clearTimeout(this._getBlocksTimer);
  }
};

//when header save all headers （onHeadersSave), header call ALL services of the node, including our block service
BlockService.prototype.onHeaders = function(callback) {

  var self = this;

  if (self._pauseSync) {
    log.warn('Block Service: pausing sync due to config option.');
    return callback();
  }

  //developer's comment (i dont quite understand)
  // if this service is waiting on block-related callbacks to be fired in the event loop,
  // then we need to wait for the _processingBlock flag to be set to false.
  // when this flag is false, we know we aren't waiting on any new blocks or historical blocks
  // that we asked for, but not yet received
  self._initialSync = true;

  //TODO-high: to read later
  //my guess is, we wait for _processingBlock to turn false, then we continue with _onHeaders
  //aysnc.retry( {...config...}, func, callback)
  //try func(next) 100 times, with 1second gap in between, when done, call func(err)
  async.retry({ interval: 1000, times: 100 }, function(next) {  // a heavy block could take a really long time to index
    return next(self._processingBlock);
  }, function(err) {
    if (err) {
      return callback(err);
    }
    self._onHeaders(callback);
  });

};

//though some technical details are yet to be understood,
//this func is bascially to trigger _startSync() once _blockInQueue==0
BlockService.prototype._onHeaders = function(callback) {

  var self = this;

  // check whether or not we need build a new tip (unlikely)
  self._resetTip(function(err) {

    if (err) {
      return callback(err);
    }

    // clear out the blocks queue, if any blocks exist there
    // if this is a reorg sitch, then there may be blocks, but none of
    // them will be saved.
    async.retry(function(next) {

      next(self._blocksInQueue > 0);

    }, function() {

      self._removeAllSubscriptions();

      // check to see if our current tip matches what the header service has.
      // if this is a reorg during our initial block sync, it is especially important
      // to see if we've synced past where the reorg/fork took place.
      self._checkTip(function(err) {

        if(err) {
          return callback(err);
        }
        //when the logic reaches here, meaning _checkTip() has finished, we now _startSync

        //developer's comment
        // we've checked the tip, handled any reorg for ourselves, and we are ready to
        // sync any new blocks that might exist after our tip
        self._reorging = false;
        self._startSync();

        // once we start syncing, we can call back to the header service, so that it can
        // process the next block in its queue.
        callback();

      });
    });
  });

};

BlockService.prototype._startBlockSubscription = function() {

  if (this._subscribedBlock) {
    return;
  }

  this._subscribedBlock = true;

  log.info('Block Service: starting p2p block subscription.');
  this._bus.on('p2p/block', this._queueBlock.bind(this));
  this._bus.subscribe('p2p/block');

};

BlockService.prototype._saveTip = function(tip, callback) {

  var tipOps = utils.encodeTip({
    hash: tip.hash,
    height: tip.height
  }, this.name);

  log.info('block service about to _saveTip using key '+util.inspect(tipOps.key));
  this._db.put(tipOps.key, tipOps.value, callback);
};

// the header service has the authoritative list of block headers.ac
// we know we have a tip that is not correct with respect to this.
// so we'll use our recent block hashes cache to find the hash that matches
// into the header service list.
BlockService.prototype._findLatestValidBlockHeader = function(callback) {

  var self = this;

  if (self._reorgToBlock) {
    return self._header.getBlockHeader(self._reorgToBlock, function(err, header) {
      if (err || !header) {
        return callback(err || new Error('Block Service: header not found to reorg to.'));
      }
      callback(null, header);
    });
  }

  var blockServiceHash = self._tip.hash;
  var blockServiceHeight = self._tip.height;
  var iterCount = 0;
  var header;

  async.until(function() {

    return iterCount++ > self._recentBlockHashes.length || header;

  }, function(next) {

    self._header.getBlockHeader(blockServiceHash, function(err, _header) {

      if (err) {
        return next(err);
      }

      var hash = blockServiceHash;
      var height = blockServiceHeight;

      blockServiceHeight--;
      blockServiceHash = self._recentBlockHashes.get(hash);

      if (!_header) {
        // try again with the previous hash of the current hash
        return next();
      }

      // if there was no reorg (the header service just received an orphan block, we should
      // get the header of our tip here.
      if (_header.hash === hash && _header.height === height) {
        header = _header;
        return next();
      }

      next();

    });
  }, function(err) {

    if (err) {
      return callback(err);
    }

    // the header could be undefined
    // this means that the header service has no record of
    // any of our recent block hashes in its indexes.
    // if some joker mines a block using an orphan block as its prev block, then the effect of this will be
    // us detecting a reorg, but not actually reorging anything
    assert(header, 'Block Service: we could not locate any of our recent block hashes in the header service ' +
      'index. Perhaps our header service sync\'ed to the wrong chain?');

    assert(header.height <= self._tip.height, 'Block Service: we found a common ancestor header whose ' +
      'height was greater than our current tip. This should be impossible.');

    callback(null, header);

  });
};

BlockService.prototype._findBlocksToRemove = function(commonHeader, callback) {

  var self = this;
  var hash = self._tip.hash;
  var height = self._tip.height;
  var blocks = [];
  var iterCount = 0;

  async.until(function() {

    return iterCount++ >= self._recentBlockHashes.length || hash === commonHeader.hash;

  }, function(next) {

    self._getBlock(hash, function(err, block) {

      if (err || !block) {
        return next(err || new Error('Block Service: block not found in index.'));
      }

      self._timestamp.getTimestamp(block.rhash(), function(err, timestamp) {

        if (err || !timestamp) {
          return callback(err || new Error('timestamp missing from reorg.'));
        }

        block.__height = height;
        block.__ts = timestamp;

        blocks.push(block);

        hash = bcoin.util.revHex(block.prevBlock);
        height--;

        next();

      });

    });

  }, function(err) {

    if (err) {
      return callback(err);
    }

    callback(null, blocks);

  });

};

BlockService.prototype._handleReorg = function(callback) {

  var self = this;

  // we want to ensure that we can re-ask for previously delievered inventory
  self._p2p.clearInventoryCache();

  var commonAncestorHeader;
  var blocksToRemove;

  async.series([

    function(next) {

      self._findLatestValidBlockHeader(function(err, _commonAncestorHeader) {

        if(err) {
          return next(err);
        }

        // nothing to do, skip and proceed
        if (_commonAncestorHeader.hash === self._tip.hash) {
          return callback();
        }

        commonAncestorHeader = _commonAncestorHeader;
        next();

      });
    },

    function(next) {

      self._findBlocksToRemove(commonAncestorHeader, function(err, _blocksToRemove) {

        if (err) {
          return next(err);
        }

        blocksToRemove = _blocksToRemove;

        assert(blocksToRemove.length >= 1 && blocksToRemove.length <= self._recentBlockHashes.length,
          'Block Service: the number of blocks to remove looks to be incorrect.');

        log.warn('Block Service: chain reorganization detected, current height/hash: ' + self._tip.height + '/' +
          self._tip.hash + ' common ancestor hash: ' + commonAncestorHeader.hash + ' at height: ' + commonAncestorHeader.height +
            ' There are: ' + blocksToRemove.length + ' block(s) to remove.');
        next();
      });
    },

    function(next) {
      self._setTip({ hash: commonAncestorHeader.hash, height: commonAncestorHeader.height }, next);
    },

    function(next) {
      self._processReorg(commonAncestorHeader, blocksToRemove, next);
    }

  ], callback);

};

BlockService.prototype._processReorg = function(commonAncestorHeader, blocksToRemove, callback) {

  var self = this;
  var operations = [];
  var blockCount = 0;
  var bar = new utils.IndeterminateProgressBar();

  async.eachSeries(blocksToRemove, function(block, next) {

    if (process.stdout.isTTY) {
      bar.tick();
    }

    self._onReorg(commonAncestorHeader.hash, block, function(err, ops) {

      if (err) {
        return next(err);
      }

      blockCount++;
      operations = operations.concat(ops);
      self._recentBlockHashes.del(block.rhash());
      next();

    });

  }, function(err) {

    if (err) {
      return callback(err);
    }

    log.info('Block Service: removed ' + blockCount + ' block(s) during the reorganization event.');
    self._db.batch(_.compact(_.flattenDeep(operations)), callback);

  });
};

BlockService.prototype._onBlock = function(block, callback) {

  var self = this;

  if (self._reorging) {
    self._processingBlock = false;
    return callback();
  }

  //we start processing, set flag to true
  self._processingBlock = true;

  //we try to find the block in our db
  self._getBlock(block.rhash(), function(err, _block) {

    if(err) {
      self._processingBlock = false;
      return self._handleError(err);
    }

    //if we found it, meaning we already have this block, we skip further processing, set the flag to false
    if (_block) {
      self._processingBlock = false;
      log.debug('Block Service: not syncing, block already in database.');
      return callback();
    }

    //if we didnt find it, meaning it is a new block, we will now process it
    self._processBlock(block, callback);

  });
};

BlockService.prototype._processBlock = function(block, callback) {

  var self = this;

  if (self.node.stopping) {
    self._processingBlock = false;
    return callback();
  }

  log.debug('Block Service: new block: ' + block.rhash());

  // common case (no reorg)
  if (!self._detectReorg(block)) {
    //if no reorg, we prceed to _saveBlock
    return self._saveBlock(block, callback);
  }

  // reorg -- in this case, we will not handle the reorg right away
  // instead, we will skip the block and wait for the eventual call to
  // "onHeaders" function. When the header service calls this function,
  // we will have a chance to clear out our block queue, check our tip,
  // discover where to reorg to, reorg all the services that rely on
  // blocks and sync from there.
  self._processingBlock = false;
  return callback();

};

BlockService.prototype._saveBlock = function(block, callback) {

  var self = this;
  block.__height = self._tip.height + 1;

  var services = self.node.services;

  //again we get all services in the node, and call their onBlock() if their onBlock func is implemented
  //see these services' dependency relationship, those who logically need block info from block service will implement onBlock()
  //e.g. transaction/address.onBlock() even block service itself implement this .onBlock(). all onBlock() will get called
  //all onBlock() return an array of dbOps, each iteraction of call driven by mapSeries() will pass the dbOps back to our callback function(err,ops) below
  //TODO-high: to check and understand how these dbOps are processed/accumulated/consumed/chained/passed back

  //my understanding is:
  //block service let all dependent services process this block, each one of them may (or may not) want to persist some data to db,
  //if they want, they pass some dbOps to callback, in the callback, we save to db
  //then mapSeries will start the next iteration on the next service

  //async.mapSeries syntax: https://caolan.github.io/async/docs.html#mapSeries
  async.mapSeries(services, function(service, next) {

    if(!service.onBlock) {
      return setImmediate(next);
    }

    //notify all services onBlock unsolicitly
    log.info('block service _saveBlock call service '+service.toString()+' .onBlock()');
    service.onBlock.call(service, block, next);

  }, function(err, ops) {

    //every onBlock() is passed with this callback function
    //this func is called (with 1 argument: ops) everytime when one iteration of onBlock() is completed
    //ops is the result returned by 'function(service, next)' above

    //important note that this is different from header service.
    //header calls onHeaders() on every services, it does not expect a returned obj, so it uses async.eachSeries()
    //block service here calls onBlock() on every services, we do expect something returned (i.e. the dbOps), so we use aysnc.mapSeries()

    if (err) {
      self._processingBlock = false;
      return callback(err);
    }

    var testrunNewOps = _.compact(_.flattenDeep(ops));
    log.info('block service got the ops returned, count '+testrunNewOps.length); //util.inspect(testrunNewOps)

    //we flatten ops and save
    self._db.batch(_.compact(_.flattenDeep(ops)), function(err) {

      if (err) {
        self._processingBlock = false;
        return callback(err);
      }

      //store it to cache, set the tip
      self._recentBlockHashes.set(block.rhash(), bcoin.util.revHex(block.prevBlock));
      self._setTip({ hash: block.rhash(), height: block.__height }, function(err) {
        if (err) {
          self._processingBlock = false;
          return callback(err);
        }

        //we finally complete all the steps, mark flag as false
        self._processingBlock = false;

        //last step, we publish the event 'block/block', notifying all subscribers there is a new block!
        //note that unlike service.onBlock is done unsolicitedly, here all subscribers solicited for this event.
        for (var i = 0; i < self._subscriptions.block.length; i++) {
          self._subscriptions.block[i].emit('block/block', block);
        }

        callback();
      });

    });
  });
};

BlockService.prototype._handleError = function(err) {
  if (!this.node.stopping) {
    log.error('Block Service: handle error ' + err);
    return this.node.stop();
  }
};

BlockService.prototype._syncBlock = function(block) {
  var self = this;

  clearTimeout(self._getBlocksTimer);

  //if the next block to be processed is somehow what we already have, skip
  if (self._lastBlockSaved === block.rhash()) {
    self._processingBlock = false;
    return;
  }

  //_saveBlock is a key func, either we are still sync or we finish sync and start waiting for new block
  //we will always hit _saveBlock
  self._saveBlock(block, function(err) {

    if(err) {
      return self._handleError(err);
    }

    self._lastBlockSaved = block.rhash();

    //after save that block, we recheck the height, emit either 'next block' or 'synced' event
    if (self._tip.height < self._header.getLastHeader().height) {
      return self.emit('next block');
    }

    self.emit('synced');

  });
};

BlockService.prototype.onBlock = function(block, callback) {
  var self = this;

  setImmediate(function() {
    log.info('block service .onBlock returning: one put op, no inspect() available yet');
    callback(null, [{
      type: 'put',
      key: self._encoding.encodeBlockKey(block.rhash()),
      value: self._encoding.encodeBlockValue(block)
    }]);
  });
};

BlockService.prototype._setTip = function(tip, callback) {
  log.debug('Block Service: Setting tip to height: ' + tip.height);
  log.debug('Block Service: Setting tip to hash: ' + tip.hash);
  this._tip = tip;
  this._saveTip(tip, callback);
};

BlockService.prototype._logSynced = function() {

  var self = this;

  if (self._reorging) {
    return;
  }

  self._getTimeSinceLastBlock(function(err, diff) {

    if (err) {
      return self._handleError(err);
    }

    log.info('Block Service: The best block hash is: ' + self._tip.hash +
      ' at height: ' + self._tip.height + '. Time between the last 2 blocks (adjusted): ' + diff);

  });

};

BlockService.prototype._onSynced = function() {
  var self = this;

  if (this._reportInterval) {
    clearInterval(this._reportInterval);
  }

  self._logProgress();
  self._initialSync = false;
  self._startBlockSubscription();
  self._logSynced(self._tip.hash);
  self._mempool.enable();
};

BlockService.prototype._startSync = function() {

  var numNeeded = Math.max(this._header.getLastHeader().height - this._tip.height, 0);

  log.info('Block Service: Gathering: ' + numNeeded + ' block(s) from the peer-to-peer network.');

  if (numNeeded > 0) {
    this.on('next block', this._sync.bind(this));
    this.on('synced', this._onSynced.bind(this));
    clearInterval(this._reportInterval);
    this._reportingInterval = setInterval(this._logProgress.bind(this), 5000);
    return this._sync();
  }

  this._onSynced();

};

BlockService.prototype._sync = function() {

  var self = this;

  if (self.node.stopping || self._reorging) {
    return;
  }

  self._processingBlock = true;

  log.debug('Block Service: querying header service for next block using tip: ' + self._tip.hash);

  //if header side best height is 1000, our tip height is only 990, and out _readAheadBlockCount is default at 2,
  //then _header.getEndHash() will return the 991th and 992th block's hashes
  //however if my tip is the highest block, getEndHash simply callback with no data
  self._header.getEndHash(self._tip, self._readAheadBlockCount, function(err, targetHash, endHash) {

    if(err) {
      self._processingBlock = false;
      return self._handleError(err);
    }

    if (!targetHash && !endHash) {
      self._processingBlock = false;
      return self.emit('synced');
    }

    // to ensure that we can receive blocks that were previously delivered
    // this will lead to duplicate transactions being sent
    self._p2p.clearInventoryCache();

    // if we don't get our callback called in due time,
    // then we must assume we've reorg'ed very shortly after
    // we made this call and we should re-compute where we are
    self._getBlocksTimer = setTimeout(function() {
      log.debug('Block Service: block timeout, emitting for next block');
      self._processingBlock = false;
      if (!self._reorging) {
        self.emit('next block');
      }
    }, 5000);

    self._getBlocksTimer.unref();

    //developer's comment
    // TODO; research how different bitcoin implementation handle block
    // locator objects. If you pass a block locator object that has one
    // block hash and that block hash is not on the main chain, then will
    // the peer send an inv for block 1 or no inv at all?

    //recall from the p2p module, getP2PBlock will callback us with single argument (the wanted block data)
    //that callback function is the self._syncBlock.bind(self) we supply here,
    //on runtime, _syncBlock(data) is invoked when _p2p is done with its job.
    self._p2p.getP2PBlock({
      filter: {
        startHash: self._tip.hash,
        endHash: endHash
      },
      blockHash: targetHash
    }, self._syncBlock.bind(self));

  });

};

BlockService.prototype._logProgress = function() {

  if (!this._initialSync) {
    return;
  }

  var progress;
  var bestHeight = Math.max(this._header.getBestHeight(), this._tip.height);

  if (bestHeight === 0) {
    progress = 0;
  } else {
    progress = (this._tip.height/bestHeight*100.00).toFixed(4);
  }

  log.info('Block Service: download progress: ' + this._tip.height + '/' +
    bestHeight + '  (' + progress + '%)');

};

module.exports = BlockService;
