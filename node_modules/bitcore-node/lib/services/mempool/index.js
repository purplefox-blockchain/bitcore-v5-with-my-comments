'use strict';
var BaseService = require('../../service');
var util = require('util');
var Encoding = require('./encoding');
var log = require('../..').log;
var utils = require('../../utils');
var _ = require('lodash');

var MempoolService = function(options) {
  BaseService.call(this, options);

  this._subscriptions = {};
  this._subscriptions.transaction = [];

  this._db = this.node.services.db;
  this._p2p = this.node.services.p2p;
  this._network = this.node.network;
  this._flush = options.flush;
  this._enabled = false;

  if (this._network === 'livenet') {
    this._network = 'main';
  }
  if (this._network === 'regtest') {
    this._network = 'testnet';
  }
};

util.inherits(MempoolService, BaseService);

//though it has memory in name, actually mempool is also persisted in db
MempoolService.dependencies = ['db'];

MempoolService.prototype.getAPIMethods = function() {

MempoolService.prototype.subscribe = function(name, emitter) {
  this._subscriptions[name].push(emitter);
  log.info(emitter.remoteAddress, 'subscribe:', 'mempool/' + name, 'total:', this._subscriptions[name].length);
};

MempoolService.prototype.unsubscribe = function(name, emitter) {
  var index = this._subscriptions[name].indexOf(emitter);
  if (index > -1) {
    this._subscriptions[name].splice(index, 1);
  }
  log.info(emitter.remoteAddress, 'unsubscribe:', 'mempool/' + name, 'total:', this._subscriptions[name].length);
};
  var methods = [
    ['getMempoolTransaction', this, this.getMempoolTransaction, 1],
    ['getTxidsByAddress', this, this.getTxsByAddress, 2],
  ];
  return methods;
};

MempoolService.prototype.getPublishEvents = function() {
  return [
    {
      name: 'mempool/transaction',
      scope: this,
      subscribe: this.subscribe.bind(this, 'transaction'),
      unsubscribe: this.unsubscribe.bind(this, 'transaction')
    }
  ];
};

MempoolService.prototype.start = function(callback) {
  var self = this;

  self._db.getPrefix(self.name, function(err, prefix) {
    if(err) {
      return callback(err);
    }
    self._encoding = new Encoding(prefix);

    if (self._flush) {
      return self._flushMempool(callback);
    }
    log.info('Mempool Service: mempool disabled until full sync.');
    callback();
  });
};

MempoolService.prototype._flushMempool = function(callback) {

  var self = this;
  var totalCount = 0;

  log.warn('Mempool Service: flushing mempool, this could take a minute.');

  var criteria = {
    gte: self._encoding.encodeMempoolTransactionKey(new Array(65).join('0')),
    lte: self._encoding.encodeMempoolTransactionKey(new Array(65).join('f'))
  };

  var timer = setInterval(function() {
    log.info('Mempool Service: removed: ' + totalCount + ' records during mempool flush.');
  }, 5000);

  timer.unref();

  var stream = self._db.createReadStream(criteria);

  stream.on('data', function(data) {
    var ops = self._getAddressOperations(self._encoding.decodeMempoolTransactionValue(data.value));
    ops.push({
      type: 'del',
      key: data.key
    });
    totalCount += ops.length;
    self._db.batch(ops);
  });

  stream.on('end', function() {
    clearInterval(timer);
    log.info('Mempool Service: completed flushing: ' + totalCount + ' tx mempool records.');
    callback();
  });

};

MempoolService.prototype.onReorg = function(args, callback) {

  var removalOps = [];

  var oldBlockList = args[1];

  for(var i = 0; i < oldBlockList.length; i++) {

    var block = oldBlockList[i];

    for(var j = 0; j < block.txs.length; j++) {

      var tx = block.txs[j];
      var key = this._encoding.encodeMempoolTransactionKey(tx.txid());
      var value = this._encoding.encodeMempoolTransactionValue(tx);

      removalOps.push({
        type: 'put',
        key: key,
        value: value
      });

      removalOps = removalOps.concat(this._getAddressOperations(tx, true));

    }
  }

  setImmediate(function() {
    callback(null, removalOps);
  });
};

MempoolService.prototype._startSubscriptions = function() {

  var self = this;
  if (self._subscribed) {
    return;
  }

  self._subscribed = true;
  if (!self._bus) {
    self._bus = self.node.openBus({remoteAddress: 'localhost-mempool'});
  }

  self._bus.on('p2p/transaction', self._onTransaction.bind(self));
  self._bus.subscribe('p2p/transaction');

};

MempoolService.prototype.enable = function() {
  log.info('Mempool Service: Mempool enabled.');
  this._startSubscriptions();
  this._enabled = true;
};

//although block service depends on mempool, mempool still need to act on block's event
//when there is a new block, mempool will remove all tx in that block from mempool
MempoolService.prototype.onBlock = function(block, callback) {

  // remove this block's txs from mempool
  var self = this;
  var ops = [];

  for(var i = 0; i < block.txs.length; i++) {
    var tx = block.txs[i];

    // tx index
    ops.push({
      type: 'del',
      key: self._encoding.encodeMempoolTransactionKey(tx.txid())
    });

    // address index
    ops = ops.concat(self._getAddressOperations(tx));

  }

  var testrunNewOps = _.compact(_.flattenDeep(ops));
  log.info('mempool service .onBlock returning: '+util.inspect(testrunNewOps));
  log.info('the mempool returned ops count is '+testrunNewOps.length);
  callback(null, ops);

};

//_getAddressOperations expects two arguments,
//if the 2nd arg is missing, we delete from mempool (deletion is a more common case for mempool)
//if the 2nd arg is there and is 'true', we add put it to mempool
MempoolService.prototype._getAddressOperations = function(tx, reverse) {

  var ops = [];
  var address;

  var action = reverse ? 'put' : 'del';

  //deal with outputs
  for(var i = 0; i < tx.outputs.length; i++) {

    var output = tx.outputs[i];
    address = utils.getAddress(output, this._network);

    if (!address) {
      continue;
    }

    ops.push({
      type: action,
      key: this._encoding.encodeMempoolAddressKey(address, tx.txid(), i, 0)
    });
  }

  //deal with inputs
  for(i = 0; i < tx.inputs.length; i++) {
    var input = tx.inputs[i];
    address = utils.getAddress(input, this._network);

    if (!address) {
      continue;
    }

    ops.push({
      type: action,
      key: this._encoding.encodeMempoolAddressKey(address, tx.txid(), i, 1)
    });
  }

  return ops;

};

//when we receive 'p2p/transaction' event
//we save it to mempool? seems so
MempoolService.prototype._onTransaction = function(tx) {
  var self = this;
  var ops = [{
      type: 'put',
      key: self._encoding.encodeMempoolTransactionKey(tx.txid()),
      value: self._encoding.encodeMempoolTransactionValue(tx)
  }];

  //for all data in the tx, we add to db
  ops = ops.concat(self._getAddressOperations(tx, true));
  self._db.batch(ops, function(err) {
    if(err) {
      log.error(err);
      self.node.stop();
    }

    //and then notify all subscribers 'mempool/transaction' e.g. insight-api
    for (var i = 0; i < self._subscriptions.transaction.length; i++) {
      self._subscriptions.transaction[i].emit('mempool/transaction', tx);
    }

  });

};

//exposed api method
//return if txis is found in mempool
MempoolService.prototype.getMempoolTransaction = function(txid, callback) {

  var self = this;

  self._db.get(self._encoding.encodeMempoolTransactionKey(txid), function(err, tx) {

    if (err) {
      return callback(err);
    }

    if (!tx) {
      return callback();
    }

    callback(null, self._encoding.decodeMempoolTransactionValue(tx));

  });

};

//exposed api method
//sample calling way is : _mempool.getTxidsByAddress(address, 'output' or 'both', next); - found in address service
MempoolService.prototype.getTxidsByAddress = function(address, type, callback) {

  var self = this;
  var results = [];
  //i dont know what are these...
  //TODO-low: find out what and why
  var start = self._encoding.encodeMempoolAddressKey(address);
  var end = Buffer.concat([ start.slice(0, -37), new Buffer(new Array(75).join('f'), 'hex') ]);

  var criteria = {
    gte: start,
    lte: end
  };

  //means we search for all keys that fall in that range?
  var stream = self._db.createKeyStream(criteria);

  stream.on('error', function() {
    return [];
  });

  //when stream ends, we return results
  stream.on('end', function() {
    callback(null, results);
  });

  //for every key
  stream.on('data', function(key) {
    var addressInfo = self._encoding.decodeMempoolAddressKey(key);
    if (type === 'input') {
      type = 1;
    } else if (type === 'output') {
      type = 0;
    }
    //basically we compare addressInfo.input with the passed in argument type, if it is same, we push to results
    if (type === 'both' || type === addressInfo.input) {
      results.push({ txid: addressInfo.txid, height: 0xffffffff });
    }
  });

};

MempoolService.prototype.stop = function(callback) {
  callback();
};

module.exports = MempoolService;
