'use strict';

var BaseService = require('../../service');
var inherits = require('util').inherits;
var Encoding = require('./encoding');
var index = require('../../');
var log = index.log;
var utils = require('../../utils');
var async = require('async');
var BN = require('bn.js');
var consensus = require('bcoin').consensus;
var assert = require('assert');
var constants = require('../../constants');
var bcoin = require('bcoin');

var HeaderService = function(options) {

  BaseService.call(this, options);

  this._tip = null;
  //we will use p2p and db services of the same node instance
  this._p2p = this.node.services.p2p;
  this._db = this.node.services.db;
  this._hashes = [];

  this.subscriptions = {};
  this.subscriptions.block = [];
  this._checkpoint = options.checkpoint || 2000; // set to -1 to resync all headers.
  this.GENESIS_HASH = constants.BITCOIN_GENESIS_HASH[this.node.network];
  this._lastHeader = null;
  this._initialSync = true;
  this._originalHeight = 0;
  this._lastHeaderCount = 2000;

  this._slowMode = options.slowMode;
};

inherits(HeaderService, BaseService);

HeaderService.dependencies = [ 'p2p', 'db' ];

//shift '1' to the left by 256bits
HeaderService.MAX_CHAINWORK = new BN(1).ushln(256);
HeaderService.STARTING_CHAINWORK = '0000000000000000000000000000000000000000000000000000000100010001';

//emitter is the instance who call this subscribe function,
//emitter is also who is interested in getting the event ('header/'+name) from header service
HeaderService.prototype.subscribe = function(name, emitter) {
  log.info('YCM: HeaderService.subscribe '+name+' '+emitter);
  this.subscriptions[name].push(emitter);
  log.info(emitter.remoteAddress, 'subscribe:', 'header/' + name, 'total:', this.subscriptions[name].length);
};

HeaderService.prototype.unsubscribe = function(name, emitter) {

  var index = this.subscriptions[name].indexOf(emitter);

  if (index > -1) {
    this.subscriptions[name].splice(index, 1);
  }

  log.info(emitter.remoteAddress, 'unsubscribe:', 'header/' + name, 'total:', this.subscriptions[name].length);

};

//header module open up three services, getBlockHeader() requires one parameter
HeaderService.prototype.getAPIMethods = function() {

  var methods = [
    ['getAllHeaders', this, this.getAllHeaders, 0],
    ['getBestHeight', this, this.getBestHeight, 0],
    ['getBlockHeader', this, this.getBlockHeader, 1]
  ];

  return methods;

};

HeaderService.prototype.getCurrentDifficulty = function() {
  var target = bcoin.mining.common.getTarget(this._lastHeader.bits);
  return bcoin.mining.common.getDifficulty(target);
};

HeaderService.prototype.getAllHeaders = function(callback) {

  var self = this;
  var start = self._encoding.encodeHeaderHeightKey(0);
  var end = self._encoding.encodeHeaderHeightKey(self._tip.height + 1);
  var allHeaders = new utils.SimpleMap();

  //greater than 0, less than tip.height+1, means we want to get all keys from db
  var criteria = {
    gte: start,
    lt: end
  };

  //this is the data stream (containing all header info from db)
  var stream = self._db.createReadStream(criteria);

  var streamErr;

  stream.on('error', function(error) {
    streamErr = error;
  });

  //stream get new data, i put it to allHeaders map
  stream.on('data', function(data) {
    var header = self._encoding.decodeHeaderValue(data.value);
    allHeaders.set(header.hash, header, header.height);
  });

  stream.on('end', function() {

    if (streamErr) {
      return streamErr;
    }

    //now we are done, return the allHeaders map (the final data)
    callback(null, allHeaders);

  });
};

//one of the three exposed api. taking in one argument, it can either be a height or block hash (or is it header hash?)
//then the call get redirected to _getHeader()
HeaderService.prototype.getBlockHeader = function(arg, callback) {

  if (utils.isHeight(arg)) {
    return this._getHeader(arg, null, callback);
  }

  return this._getHeader(null, arg, callback);

};

//our bestHeight is the tip's height
HeaderService.prototype.getBestHeight = function() {
  return this._tip.height;
};

HeaderService.prototype._adjustTipBackToCheckpoint = function() {

  //originalHeight is the tip height in our last round of sync?
  this._originalHeight = this._tip.height;

  //to resync from the genesis block, _checkpoint = -1 or _checkpoint is even higher than _tip.height which is ridiculous
  if (this._checkpoint === -1 || this._tip.height < this._checkpoint) {
    //we set _tip.height=0 and start from scratch
    this._tip.height = 0;
    this._tip.hash = this.GENESIS_HASH;
  } else {
    //deduct _checkpoint from _tip.height????
    this._tip.height -= this._checkpoint;
  }

};

HeaderService.prototype._setGenesisBlock = function(callback) {

  assert(this._tip.hash === this.GENESIS_HASH, 'Expected tip hash to be genesis hash, but it was not.');

  var genesisHeader = {
    hash: this.GENESIS_HASH,
    height: 0,
    chainwork: HeaderService.STARTING_CHAINWORK,
    version: 1,
    prevHash: new Array(65).join('0'),
    timestamp: 1231006505,
    nonce: 2083236893,
    bits: 0x1d00ffff,
    merkleRoot: '4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b'
  };

  this._lastHeader = genesisHeader;

  var dbOps = [
    {
      type: 'put',
      key: this._encoding.encodeHeaderHeightKey(0),
      value: this._encoding.encodeHeaderValue(genesisHeader)
    },
    {
      type: 'put',
      key: this._encoding.encodeHeaderHashKey(this.GENESIS_HASH),
      value: this._encoding.encodeHeaderValue(genesisHeader)
    }
  ];

  this._db.batch(dbOps, callback);

};

//header service is started from node
//this is the entry point of this module
HeaderService.prototype.start = function(callback) {

  var self = this;

  //call the array of functions in series, calll main callback func when an error is encountered
  //'next' is the callback function
  //https://stackoverflow.com/questions/25705067/using-async-waterfall-in-node-js
  async.waterfall([
    //what is this for?
    function(next) {
      self._db.getPrefix(self.name, next);
    },
    //what is this for?
    function(prefix, next) {
      self._encoding = new Encoding(prefix);
      self._db.getServiceTip(self.name, next);
    },
    //what is this for?
    function(tip, next) {

      self._tip = tip;

      self._adjustTipBackToCheckpoint();

      async.waterfall([

        function(next) {
          if (self._tip.height === 0) {
            return self._setGenesisBlock(next);
          }
          next();
        },

        function(next) {
          self._adjustHeadersForCheckPointTip(next);
        }

      ], function(err) {
        if (err) {
          return next(err);
        }
        next();
      });
    }

  ], function(err) {

      if (err) {
        return callback(err);
      }

      //my understanding: anything that is pushed to _blockProcessor, will be passed to
      //_processBlocks() as arguments (note that consumed as arg is bind()'s effect)
      //or in other words
      //dataContainer = aysnc.queue(someFucntion.bind(self))
      //means for each data element in container, aysnc call someFunction(dataElement)
      //aysnc.queue syntax: https://caolan.github.io/async/docs.html#queue

      // set block worker queue, concurrency 1
      self._blockProcessor = async.queue(self._processBlocks.bind(self));

      self._setListeners();
      //new a bus, set it to _bus
      self._bus = self.node.openBus({remoteAddress: 'localhost-header'});
      callback();

  });

};

HeaderService.prototype.stop = function(callback) {

  callback();

};

// ensures only one listener will ever be registered
HeaderService.prototype._startHeaderSubscription = function() {

  if (this._subscribedHeaders) {
    return;
  }
  this._subscribedHeaders = true;
  log.info('Header Service: subscribed to p2p headers.');
  this._bus.on('p2p/headers', this._onHeaders.bind(this));
  this._bus.subscribe('p2p/headers');

};

//bind() syntax: function.bind(thisArg[, arg1[, arg2[, ...]]])
//bind() returns a bound (modified) function that will have the correct context ("this") for calling
//the original function and the arg123 prepended to the given arguments during the invokation.
HeaderService.prototype.getPublishEvents = function() {

  return [
    {
      name: 'header/block',
      scope: this,
      subscribe: this.subscribe.bind(this, 'block'),  //thisHeader.subscribe('block', whateverActualArgumentsOnRuntime)
      unsubscribe: this.unsubscribe.bind(this, 'block') //thisHeader.unsubscribe('block', whateverActualArgumentsOnRuntime)
    }
  ];

};

//this is called when header receives 'p2p/block' event from p2p
//push the block to the _blockProcessor queue
HeaderService.prototype._queueBlock = function(block) {

  var self = this;

  self._blockProcessor.push(block, function(err) {

    if (err) {
      return self._handleError(err);
    }

    //callback func print completed processing block once the func is callbacked
    log.debug('Header Service: completed processing block: ' + block.rhash() + ' prev hash: ' + bcoin.util.revHex(block.prevBlock));

  });

};

//given a block, getBlockHeader(blockHash) then _persistHeader(block)
HeaderService.prototype._processBlocks = function(block, callback) {

  var self = this;

  if (self.node.stopping || self._reorging) {
    return callback();
  }

  self.getBlockHeader(block.rhash(), function(err, header) {
    if(err) {
      return self._handleError(err);
    }

    if (header) {
      log.debug('Header Service: block already exists in data set.');
      return callback();
    }

    self._persistHeader(block, callback);
  });

};

HeaderService.prototype._persistHeader = function(block, callback) {

  var self = this;

  if (!self._detectReorg(block)) {
    //the main part of _persistHeader
    return self._syncBlock(block, callback);
  }

  self._reorging =  true;
  self.emit('reorg');

  self._handleReorg(block, function(err) {

    if(err) {
      return callback(err);
    }

    self._startSync();
    callback();
  });
};

HeaderService.prototype._formatHeader = function(block) {

  var header = block.toHeaders().toJSON();
  header.timestamp = header.ts;
  header.prevHash = header.prevBlock;
  return header;

};

//kind of persist this block (or block header?) info to the db
HeaderService.prototype._syncBlock = function(block, callback) {

  var self = this;

  var header = self._formatHeader(block);

  log.debug('Header Service: new block: ' + block.rhash());

  var dbOps = self._getDBOpForLastHeader(header);
  dbOps = dbOps.concat(self._onHeader(header));
  self._saveHeaders(dbOps, callback);
};

//seems it is not called interllay anywhere in header/index.js, but is it called by external module?
HeaderService.prototype._broadcast = function(block) {
  for (var i = 0; i < this.subscriptions.block.length; i++) {
    this.subscriptions.block[i].emit('header/block', block);
  }
};

//process each header
HeaderService.prototype._onHeader = function(header) {

  if (!header) {
    return;
  }

  //continue to complete the info
  header.height = this._lastHeader.height + 1;
  header.chainwork = this._getChainwork(header, this._lastHeader).toString(16, 64);

  if (!header.timestamp) {
    header.timestamp = header.time;
  }

  //while processing every header, we set all these values accordingly so that we know where we have progressed
  this._lastHeader = header;
  this._tip.height = header.height;
  this._tip.hash = header.hash;

  //we will add headerHash->headerData, headerHeight->headerData to the db
  return [
    {
      type: 'put',
      key: this._encoding.encodeHeaderHashKey(header.hash),
      value: this._encoding.encodeHeaderValue(header)
    },
    {
      type: 'put',
      key: this._encoding.encodeHeaderHeightKey(header.height),
      value: this._encoding.encodeHeaderValue(header)
    }
  ];

};

//for each header, we set .nextHash accordingly
HeaderService.prototype._transformHeaders = function(headers) {
  var ret = [];
  for(var i = 0; i < headers.length; i++) {
    var hdr = headers[i].toObject();
    if (headers[i+1]) {
      hdr.nextHash = headers[i+1].hash;
    }
    ret.push(hdr);
  }
  return ret;
};

//the last header in db being the last header, has no info on its next header
//since now we have the next header, we set nextHash and get this info persisted
//by removing two entries and readding two entries on lastheader
HeaderService.prototype._getDBOpForLastHeader = function(nextHeader) {
  // we need to apply the next hash value on the last-processed header
  // delete operation for the last header already in the db.
  // then put operation for the updated last header (with the next hash)
  this._lastHeader.nextHash = nextHeader.hash;
  var keyHash = this._encoding.encodeHeaderHashKey(this._lastHeader.hash);

  assert(this._lastHeader.height >= 0, 'Trying to save a header with incorrect height.');

  var keyHeight = this._encoding.encodeHeaderHeightKey(this._lastHeader.height);
  var value = this._encoding.encodeHeaderValue(this._lastHeader);

  //we return 4 operations
  // - delete a key from db (last header's hash)
  // - delete a key from db (last header's height)
  // - insert a key to db (last block or block header hash -> header data)
  // - insert a key to db (last block height -> header data)
  return [
    {
      type: 'del',
      key: keyHash
    },
    {
      type: 'del',
      key: keyHeight
    },
    {
      type: 'put',
      key: keyHash,
      value: value
    },
    {
      type: 'put',
      key: keyHeight,
      value: value
    }
  ];
};

//when we receive some headers...
HeaderService.prototype._onHeaders = function(headers) {

  var self = this;

  //if the event data has 0 length, we directly say "we are done"
  if (headers.length === 0) {
    self._onHeadersSave(function(err) {
      if (err) {
        return self._handleError(err);
      }
    });
  }

  // used to tell the header sync loop when to stop
  self._lastHeaderCount = headers.length;

  log.debug('Header Service: Received: ' + headers.length + ' header(s).');

  //if the 1st element of headers data is null, we return
  if (!headers[0]) {
    return;
  }

  //preprocess the last header by setting its .nextHeader
  var dbOps = self._getDBOpForLastHeader(headers[0]);

  //preprocess all incoming headers, by setting theirs .nextHeader
  var transformedHeaders = self._transformHeaders(headers);

  //now all new headers including the last old header has .nextHeader set
  for(var i = 0; i < transformedHeaders.length; i++) {

    var header = transformedHeaders[i];

    //just to play safe
    assert(self._lastHeader.hash === header.prevHash, 'headers not in order: ' + self._lastHeader.hash +
      ' -and- ' + header.prevHash + ' Last header at height: ' + self._lastHeader.height);

    //call _onHeader to trigger 'formal processing' for ONE header
    var ops = self._onHeader(header);

    dbOps = dbOps.concat(ops);

  }

  self._saveHeaders(dbOps, function(err) {
    if (err) {
      return self._handleError(err);
    }
  });

};

HeaderService.prototype._handleError = function(err) {
  log.error('Header Service: ' + err);
  this.node.stop();
};

//_saveHeaders() persist all the headers, when this is done, call _onHeadersSave()?
HeaderService.prototype._saveHeaders = function(dbOps, callback) {

  var self = this;
  var tipOps = utils.encodeTip(self._tip, self.name);

  //TODO-low: we save tip data to db. but is it used anywhere?
  dbOps.push({
    type: 'put',
    key: tipOps.key,
    value: tipOps.value
  });

  self._db.batch(dbOps, function(err) {
    if(err) {
      return callback(err);
    }
    self._onHeadersSave(callback);
  });
};

//so all headers have been saved...
HeaderService.prototype._onHeadersSave = function(callback) {
  var self = this;

  self._logProgress();

  //we check again whether the sync indeed complete, if not we _sync() again
  if (!self._syncComplete()) {
    self._sync();
    return callback();
  }

  //if sync indeed complete, we end subscription and switch to block subscription
  self._endHeaderSubscription(); // we don't need headers any more
  self._startBlockSubscription(); // we need new blocks coming to us aynchronuously

  self._setBestHeader();

  if (!self._initialSync) {
    return callback();
  }

  // this will happen after an inital start up and sync -and- also after a chain reorg
  log.info('Header Service: sync complete.');
  self._initialSync = false;

  //aysnc.eachSeries syntax: https://caolan.github.io/async/docs.html#eachSeries
  //for element in node.services, run the function, each at a time)
  //we inform all services by calling their service.onHeaders()

  //note that all services (e.g. block) will have their onHeaders call unsolicitedly.
  //they dont need to subscribe for this event, they will still get called
  async.eachSeries(self.node.services, function(service, next) {
    //if onHeaders of that service is implemented
    if (service.onHeaders) {
      //we call that func
      return service.onHeaders.call(service, next);
    }
    next();
  }, function(err) {

    //every onHeaders() is passed with this callback function
    //this func is called (with no argument) everytime when one iteration of onHeaders() is completed

    if (err) {
      return callback(err);
    }

    self.emit('reorg complete');
    self._reorging = false;
    callback();

  });

};

HeaderService.prototype._endHeaderSubscription = function() {
  if (this._subscribedHeaders) {
    this._subscribedHeaders = false;
    log.info('Header Service: p2p header subscription no longer needed, unsubscribing.');
    this._bus.unsubscribe('p2p/headers');
  }
};

//the runtime logs read
//  [2018-10-28T02:33:17.867Z] info: Header Service: starting p2p block subscription.
//  [2018-10-28T02:33:17.867Z] info: YCM: Bus.subscribe p2p/block
//  [2018-10-28T02:33:17.867Z] info: YCM: P2P.subscribe block [object Object]
//  [2018-10-28T02:33:17.867Z] info: localhost-header subscribe: p2p/block total: 1
HeaderService.prototype._startBlockSubscription = function() {

  if (this._subscribedBlock) {
    return;
  }

  this._subscribedBlock = true;

  log.info('Header Service: starting p2p block subscription.');
  //in the future when header gets a p2p/block event via _bus, header invokes _queueBlock() func
  //we register this handler first before we subscribe shortly
  this._bus.on('p2p/block', this._queueBlock.bind(this));
  //header subscribes itself to p2p/block event via _bus
  this._bus.subscribe('p2p/block');

};

//read developer's comment
HeaderService.prototype._syncComplete = function() {

  //developer's comment
  // we always ask for the max number of headers, which is 2000.
  // so any response with < 2000 means we have reached the end of the headers list.
  // we could make an extra call if the number of total headers is multiple of 2000.
  return this._lastHeaderCount < 2000;

};

HeaderService.prototype._setBestHeader = function() {
  var bestHeader = this._lastHeader;
  log.debug('Header Service: ' + bestHeader.hash + ' is the best block hash.');
};

//get the header based on the height or block hash (or is it header hash?)
HeaderService.prototype._getHeader = function(height, hash, callback) {

  var self = this;

  /*jshint -W018 */
  if (!hash && !(height >= 0)) {
    /*jshint +W018 */
    return callback(new Error('invalid arguments'));
  }

  //shortcut if _lastHeader is the block header we are looking for
  if (height === self._lastHeader.height || hash === self._lastHeader.hash) {
    return callback(null, self._lastHeader);
  }

  //either hash or height, we encode it
  var key;
  if (hash) {
    key = self._encoding.encodeHeaderHashKey(hash);
  } else {
    key = self._encoding.encodeHeaderHeightKey(height);
  }

  //we directly search the db
  self._db.get(key, function(err, data) {

    if (err) {
      return callback(err);
    }

    if (!data) {
      return callback();
    }

    callback(null, self._encoding.decodeHeaderValue(data));

  });

};

// we aren't go to get fancy with this, we are just going to wipe out the
// last 2000 or so headers and re-ask our peer for the last set of headers.
HeaderService.prototype._detectReorg = function(block) {
  return bcoin.util.revHex(block.prevBlock) !== this._lastHeader.hash;
};

HeaderService.prototype._handleReorg = function(block, callback) {

  var self = this;

  log.warn('Header Service: Reorganization detected, current tip hash: ' +
    self._tip.hash + ', new block causing the reorg: ' + block.rhash());

  // at this point, we have a block that does not directly link to our
  // last header. This is all we know for sure. We may not have this block's
  // previous blocks either, which means we need to go out and re-retrieve
  // a list of the latest headers and gather those blocks. If the peer hasn't
  // completed its own reorganization, we may need to defer the rest of the system
  // reorg until we get a list of headers that correctly links from this block
  // all the way back to the genesis block.

  // first, we'll adjust the tip back to the last checkpoint just like we do when
  // the service starts up.
  self._adjustTipBackToCheckpoint();

  // then, we'll get the last header from the database which will nuke out all the
  // headers that are greater than new tip height.
  self._adjustHeadersForCheckPointTip(callback);

};

//this._p2p is a bitcore-p2p/lib/poo.js, when a new peer is ready in p2p network
//this._p2p will get a peerready event, it will scan through all peers and get the best height
//this._p2p pass that best height event to this header service, here we call _onBestHeight
HeaderService.prototype._setListeners = function() {
  this._p2p.on('bestHeight', this._onBestHeight.bind(this));
};

//the only event that this header service is interested in
//it trigger everything afterwards
HeaderService.prototype._onBestHeight = function(height) {
  log.info('Header Service: Best Height is: ' + height);
  this._bestHeight = height;
  this._startSync();
};

HeaderService.prototype._startSync = function() {

  log.info('YCM: header._startSync()');

  var self = this;

  //developer's comments
  // remove all listeners
  // ensure the blockProcessor is finished processing blocks (empty queue)
  // then proceed with gathering new set(s) of headers
  // if our tip height is less than the best height of this peer, then:
  // 1. the peer is not fully synced.
  // 2. the peer has reorg'ed and we need to handle this

  self._initialSync = true;
  log.debug('Header Service: starting sync routines, ensuring no pre-exiting subscriptions to p2p blocks.');
  self._removeAllSubscriptions();

  //https://caolan.github.io/async/docs.html#retry
  //https://caolan.github.io/async/global.html -> if no error occurred, it should be called with null as the first argument, and any additional result arguments that may apply, to signal successful completion
  //the syntax used here is retry(opts,task)
  //it only retry and keep trying when the condition is true (which is _blockProcessor still has data)
  //it is like while(_blockProcess.length!=0) { runMyFunction(); } but in a completely async manner

  //the syntax is:
  //- task = function(next)
  //- finalcallback = function(err,result)
  //the logic is:
  //- the task i.e. function(next) will be retried until it is successful or hit the retry count (default at 5)
  //- the full syntax of the function(next) is a function with no arguments but with one callback. as with all other callbacks, at least in async module, callback has this param list callback(err, results...). so put them together, we have function(next) = function(callback(err,results))
  //- now in the function body of function(next), there is no other code, without doing anything, we directly call the callback using next(self._blocksInQueue > 0), when this boolean expression represents the 'err' above.
  //- when the boolean expression is true, meaning this retry has error, meaning async.retry() will continue to retry, until this boolean turns false or until the max retry count hits.
  async.retry(function(next) {

    next(self._blockProcessor.length() !== 0);

  }, function() {

    self._reorging = false;
    //the number of blocks to be sync
    var numNeeded = Math.max(self._bestHeight, self._originalHeight) - self._tip.height;

    //let's recall the busniess logic,
    //we get a 'bestHeight' from p2p, of course when we check it is likely we need to sync (numNeeded>0)
    //it is also possible that here in header, we are already in sync, so numNeed may be 0

    // common case
    if (numNeeded > 0) {
      log.info('Header Service: Gathering: ' + numNeeded + ' ' + 'header(s) from the peer-to-peer network.');
      return self._sync();
    }

    // next most common case
    if (numNeeded === 0) {
      log.info('Header Service: we seem to be already synced with the peer.');
      return self._onHeadersSave(function(err) {
        if(err) {
          return self._handleError(err);
        }
      });
    }

    // very uncommon! when a peer is not sync'ed or has reorg'ed
    self._handleLowTipHeight();

  });

};

HeaderService.prototype._removeAllSubscriptions = function() {
  this._bus.unsubscribe('p2p/headers');
  this._bus.unsubscribe('p2p/block');
  //throughout the header/index.js, when we unsub via _bus, we set the flag to false, vice versa.
  this._subscribedBlock = false;
  this._subscribedHeaders = false;
  this._bus.removeAllListeners();
};

//special case, ignore for now
// this should fire in edge cases where a new peer is not quite synced
HeaderService.prototype._findReorgConditionInNewPeer = function(callback) {

  var self = this;

  var newPeerHeaders = new utils.SimpleMap();
  var headerCount = 0;

  self.getAllHeaders(function(err, allHeaders) {

    if (err) {
      return callback(err);
    }

    log.warn('Header Service: re-subscribing to p2p headers to gather new peer\'s headers.');
    self._subscribedHeaders = true;
    self._bus.subscribe('p2p/headers');
    self._bus.on('p2p/headers', function(headers) {

      headers.forEach(function(header) {
        newPeerHeaders.set(header.hash, header);
        headerCount++;
      });

      if (headerCount < self._bestHeight) {
        return self._getP2PHeaders(headers[headers.length - 1].hash);
      }

      // We should have both sets of headers, work from latest header to oldest and find the common header.
      // Use the new set since we know this is a shorter list.
      var reorgInfo = { commonHeader: null, blockHash: null };

      for(var i = newPeerHeaders.length - 1; i >= 0; i--) {

        var newHeader = newPeerHeaders.getIndex(i);
        var oldHeader = allHeaders.get(newHeader.hash);

        if (oldHeader) {

          // we found a common header, but no headers that at a greater height, this peer is not synced
          if (!reorgInfo.blockHash) {
            return callback();
          }

          reorgInfo.commonHeader = oldHeader;
          return callback(null, reorgInfo);
        }

        reorgInfo.blockHash = newHeader.hash;
      }

      // nothing matched...
      // at this point, we should wonder if we are connected to the wrong network
      assert(true, 'We tried to find a common header between current set of headers ' +
        'and the new peer\'s set of headers, but there were none. This should be impossible ' +
          ' if the new peer is using the same genesis block.');
    });

    self._getP2PHeaders(self.GENESIS_HASH);

  });

};

//special case, ignore for now
HeaderService.prototype._handleLowTipHeight = function() {
  var self = this;

  log.warn('Header Service: Connected Peer has a best height (' + self._bestHeight + ') which is lower than our tip height (' +
    self._tip.height + '). This means that this peer is not fully synchronized with the network -or- the peer has reorganized itself.' +
    ' Checking the new peer\'s headers for a reorganization event.');

  self._findReorgConditionInNewPeer(function(err, reorgInfo) {

    if (err) {
      return self._handleError(err);
    }

    // Our peer is not yet sync'ed.
    // We will just turn on our block subscription and wait until we get a block we haven't seen
    if (!reorgInfo) {
      log.info('Header Service: it appears that our peer is not yet synchronized with the network '  +
        '(we have a strict superset of the peer\'s blocks). We will wait for more blocks to arrive...');
      return self._onHeadersSave(function(err) {
        if (err) {
          return self._handleError(err);
        }
      });
    }

    // our peer has reorg'ed to lower overall height.
    // we should get the first block after the split, reorg back to this height - 1 and then continue.
    // we should still have no listeners for anything, blocks, headers, etc. at this point
    self._p2p.getP2PBlock({
      filter: {
        startHash: reorgInfo.commonHeader.hash,
        endHash: 0
      },
      blockHash: reorgInfo.blockHash
    }, function(block) {

      self._initialSync = true;

      self._handleReorg(block, reorgInfo.commonHeader, function(err) {

        if(err) {
          self._handleError(err);
        }

        // run start sync again. This time we should be back on track.
        self._startSync();

      });
    });

  });


};

HeaderService.prototype._logProgress = function() {

  if (!this._initialSync || this._lastTipHeightReported === this._tip.height) {
    return;
  }

  var progress;
  var bestHeight = Math.max(this._bestHeight, this._lastHeader.height);

  if (bestHeight === 0) {
    progress = 0;
  } else {
    progress = (this._tip.height/bestHeight*100.00).toFixed(2);
  }

  log.info('Header Service: download progress: ' + this._tip.height + '/' +
    bestHeight + '  (' + progress + '%)');

  this._lastTipHeightReported = this._tip.height;
};

HeaderService.prototype._getP2PHeaders = function(hash) {

  var self = this;
  self._p2p.getHeaders({ startHash: hash });

};

HeaderService.prototype._sync = function() {

  this._startHeaderSubscription(); // ensures only one listener will ever be registered
  this._getP2PHeaders(this._tip.hash);

};

//called by block service line 1188+ 'self._header.getEndHash'
//blockCount is the readAheadBlockCount, defined in block service, default at 2
//if header height 1000, the tip height 990 (passed in by block), numResultsNeeded will be 2+1 = 3
//(however if block service tip is same as header's tip, then numResultsNeeded is 0, this function is skipped)
//the end result of this function is
//it return the hash of the 991th block AND the hash of 992th block (992=990+2)
//TODO-low: why do we need to return the hash of 992th block??
HeaderService.prototype.getEndHash = function(tip, blockCount, callback) {

  assert(blockCount >= 1, 'Header Service: block count to getEndHash must be at least 1.');

  var self = this;


  var numResultsNeeded = Math.min((self._tip.height - tip.height), blockCount + 1);

  if (numResultsNeeded === 0 && self._tip.hash === tip.hash) {
    return callback();
  }

  if (numResultsNeeded <= 0) {
    return callback(new Error('Header Service: block service is mis-aligned '));
  }

  //we fetch the immediate following block after the given tip block, and the x (x=numResultsNeeded) blocks after that
  var startingHeight = tip.height + 1;
  var start = self._encoding.encodeHeaderHeightKey(startingHeight);
  var end = self._encoding.encodeHeaderHeightKey(startingHeight + blockCount);
  var results = [];

  var criteria = {
    gte: start,
    lte: end
  };

  var stream = self._db.createReadStream(criteria);

  var streamErr;

  stream.on('error', function(error) {
    streamErr = error;
  });

  stream.on('data', function(data) {
    results.push(self._encoding.decodeHeaderValue(data.value).hash);
  });

  stream.on('end', function() {

    if (streamErr) {
      return streamErr;
    }

    assert(results.length === numResultsNeeded, 'getEndHash returned incorrect number of results.');

    var index = numResultsNeeded - 1;
    var endHash =  index <= 0 || !results[index] ? 0 : results[index];

    if (self._slowMode) {
      return setTimeout(function() {
        callback(null, results[0], endHash);
      }, self._slowMode);
    }

    callback(null, results[0], endHash);

  });

};

HeaderService.prototype.getLastHeader = function() {
  assert(this._lastHeader, 'Last header should be populated.');
  return this._lastHeader;
};

HeaderService.prototype._adjustHeadersForCheckPointTip = function(callback) {

  var self = this;

  var removalOps = [];

  var start = self._encoding.encodeHeaderHeightKey(self._tip.height);
  var end = self._encoding.encodeHeaderHeightKey(0xffffffff);

  log.info('Getting last header synced at height: ' + self._tip.height);

  var criteria = {
    gte: start,
    lte: end
  };

  var stream = self._db.createReadStream(criteria);

  var streamErr;
  stream.on('error', function(error) {
    streamErr = error;
  });

  stream.on('data', function(data) {
    var header  = self._encoding.decodeHeaderValue(data.value);

    // any records with a height greater than our current tip height can be scheduled for removal
    // because they will be replaced shortly
    // and for every height record, we must also remove its hash record
    if (header.height > self._tip.height) {
      removalOps.push({
        type: 'del',
        key: data.key
      });
      removalOps.push({
        type: 'del',
        key: self._encoding.encodeHeaderHashKey(header.hash)
      });
      return;
    }

    if (header.height === self._tip.height) {
      self._lastHeader = header;
    }

  });

  stream.on('end', function() {

    if (streamErr) {
      return streamErr;
    }

    assert(self._lastHeader, 'The last synced header was not in the database.');
    self._tip.hash = self._lastHeader.hash;
    self._tip.height = self._lastHeader.height;
    self._db.batch(removalOps, callback);

  });

};

HeaderService.prototype._getChainwork = function(header, prevHeader) {

  var prevChainwork = new BN(new Buffer(prevHeader.chainwork, 'hex'));

  return this._computeChainwork(header.bits, prevChainwork);
};

HeaderService.prototype._computeChainwork = function(bits, prev) {

  var target = consensus.fromCompact(bits);

  if (target.isNeg() || target.cmpn(0) === 0) {
    return new BN(0);
  }

  var proof =  HeaderService.MAX_CHAINWORK.div(target.iaddn(1));

  if (!prev) {
    return proof;
  }

  return proof.iadd(prev);

};

module.exports = HeaderService;

