'use strict';

var fs = require('fs');
var http = require('http');
var https = require('https');
var express = require('express');
var bodyParser = require('body-parser');
var socketio = require('socket.io');
var inherits = require('util').inherits;

var BaseService = require('../../service');
var bitcore = require('bitcore-lib');
var _ = bitcore.deps._;
var index = require('../../');
var log = index.log;

//look at the doc below, my understanding is, the web module
// - register the path for each service, and delegate requests on runtime to the service
// - handle events via getPublishEvents
// - route connections that declared by each service via their getAPIMethods()

/**
 * This service represents a hub for combining several services over a single HTTP port. Services
 * can extend routes by implementing the methods `getRoutePrefix` and `setupRoutes`. Additionally
 * events that are exposed via the `getPublishEvents` and API methods exposed via `getAPIMethods`
 * will be available over a socket.io connection.
 *
 * @param {Object} options
 * @param {Node} options.node - A reference to the node
 * @param {Boolean} options.https - Enable https, will default to node.https settings.
 * @param {Object} options.httpsOptions - Options passed into https.createServer, defaults to node settings.
 * @param {String} options.httpsOptions.key - Path to key file
 * @param {String} options.httpsOptions.cert - Path to cert file
 * @param {Boolean} options.enableSocketRPC - Option to enable/disable websocket RPC handling
 * @param {Number} options.port - The port for the service, defaults to node settings.
 */
var WebService = function(options) {
  var self = this;
  this.node = options.node;
  this.https = options.https || this.node.https;
  this.httpsOptions = options.httpsOptions || this.node.httpsOptions;
  //is it the port defined in  ~/.bitcore/bitcore-node.json?
  this.port = options.port || this.node.port || 3456;

  // set the maximum size of json payload, defaults to express default
  // see: https://github.com/expressjs/body-parser#limit
  this.jsonRequestLimit = options.jsonRequestLimit || '100kb';

  //if this is not defined, we will assume it to be true
  this.enableSocketRPC = _.isUndefined(options.enableSocketRPC) ?
    WebService.DEFAULT_SOCKET_RPC : options.enableSocketRPC;

  //when the node is ready, we do this...
  this.node.on('ready', function() {
    //all events collected recursively are set to .eventNames
    self.eventNames = self.getEventNames();
    //expose all services that need to be exposed on http
    self.setupAllRoutes();
    self.server.listen(self.port);
    self.createMethodsMap();
  });
  BaseService.call(this, options);
};

inherits(WebService, BaseService);

WebService.dependencies = [];
WebService.DEFAULT_SOCKET_RPC = true;

/**
 * Called by Node to start the service
 * @param {Function} callback
 */
WebService.prototype.start = function(callback) {
  //leverage on express for web related stuff
  this.app = express();
  //read this and learn https://stackoverflow.com/questions/38306569/what-does-body-parser-do-with-express
  //essentially body-parser module makes sure the incoming request's content is unzipped (if needed), parsed (if necessary)
  //and made available via req.body
  this.app.use(bodyParser.json({limit: this.jsonRequestLimit}));

  //create a server using express instance
  if(this.https) {
    this.transformHttpsOptions();
    this.server = https.createServer(this.httpsOptions, this.app);
  } else {
    this.server = http.createServer(this.app);
  }

  //attach socket.io to the httpserver
  //according to some website, "Socket.io is a solution designed to unify communications between a browser and a server. It is useful to implement highly dynamic web sites, and hides the different underlying solutions/protocols "
  this.io = socketio.listen(this.server);

  //socketHandler is a function defined in this js file
  //'web' module handle any new connection and let socketHandler to handle it.
  //and if we take a look at the socketHandler() function, we will see, for a socket.io connection
  //we will handle incoming messages and subscribe/unsubscribe events.
  //this is pretty much all we need to do for a generic web module
  this.io.on('connection', this.socketHandler.bind(this));

  setImmediate(callback);
};

/**
 * Called by Node. stop the service
 * @param {Function} callback
 */
WebService.prototype.stop = function(callback) {
  var self = this;

  setImmediate(function() {
    if(self.server) {
      self.server.close();
    }
    callback();
  });
};

/**
 * This function will iterate over all of the available services gathering
 * all of the exposed HTTP routes.
 */
WebService.prototype.setupAllRoutes = function() {
  log.info('printing : service name - effective routePrefix - effective apiPrefix');
  for(var key in this.node.services) {
    var subApp = new express();
    var service = this.node.services[key];

    //for all services in the node, if getRoutePrefix and setupRoutes is defined, then we do something
    //if either one is not defined, this func does nothing

    //refer to insight-ui module for illustrations on how setupRoutes is used
    //In insight-ui/bitcore-node/index.js,
    //InsightUI.prototype.getRoutePrefix = function() { return this.routePrefix; };
    //InsightUI.prototype.setupRoutes = function(app, express) {...}
    if(service.getRoutePrefix && service.setupRoutes) {
      //this.app uses /thisServiceRoutePrefix as root to serve requests
      this.app.use('/' + this.node.services[key].getRoutePrefix(), subApp);
      //deleget the actual serving to that service's setupRoutes
      //my guess is, for example for insight-ui, it use all files in 'public' dir for static contents
      this.node.services[key].setupRoutes(subApp, express);
      log.info('==> '+key+' - '+this.node.services[key].getRoutePrefix()+' - '+this.node.services[key].apiPrefix);
    } else {
      log.debug('No routes defined for: ' + key);
    }
  }
};

/**
 * This function will construct an API methods map of all of the
 * available methods that can be called from enable services.
 */
WebService.prototype.createMethodsMap = function() {
  var self = this;
  //recall that, in lib/node.js, this getAllAPIMethods is concatenating all arrays from each service's getAPIMethods()
  var methods = this.node.getAllAPIMethods();
  this.methodsMap = {};

  //look at bitcore-node/lib/services/header/index.js line 60+, ['getAllHeaders', this, this.getAllHeaders, 0]
  //each method has the following data structure [name,instance,method,argcount]
  //we reconstruct the fn and also register the arg count to the methodsMap

  //how to use this methodsMap? somewhere down this file has an example
  //methodsMap[message.method].fn.apply(this, params);
  //to understand it,
  // - methodsMap[someName].fn is the function itself
  // - fn.apply(someIntance, someArguments) to actually invoke the function
  // - the someArguments above will be the 'arguments' below
  //we also have an example for args in this file
  //'Expected ' + this.methodsMap[message.method].args + ' parameter(s)'
  methods.forEach(function(data) {
    var name = data[0];
    var instance = data[1];
    var method = data[2];
    var args = data[3];

    if (self.methodsMap[name]) {
        log.warn('potentially double register in methodsMap, method name is '+instance.name);
    }

    self.methodsMap[name] = {
      //this is like java's reflection
      //it is equivalent to instance.method(args) function
      fn: function() {
        return method.apply(instance, arguments);
      },
      args: args
    };
    //we save this function together with the mandatory argument count to methodsMap[name]
    //so it means the method name each service register must be unique among all services??
    //we print all class and methods out and add a log.warn() above to hightlight any possible clash

    //var itype = util.inspect(instance, { depth:1 });
    log.info('methodsMap - ' + instance.name + ' - ' + name);

    //sample outputs - this include all api methods exposed by each service' getAPIMethods
    // methodsMap - timestamp - getBlockHashesByTimestamp
    // methodsMap - p2p - clearInventoryCache
    // methodsMap - p2p - getP2PBlock
    // methodsMap - p2p - getHeaders
    // methodsMap - p2p - getMempool
    // methodsMap - p2p - sendTransaction
    // methodsMap - header - getAllHeaders
    // methodsMap - header - getBestHeight
    // methodsMap - header - getBlockHeader
    // methodsMap - mempool - getMempoolTransaction
    // methodsMap - mempool - getTxidsByAddress
    // methodsMap - block - getInfo
    // methodsMap - block - getBlock
    // methodsMap - block - getRawBlock
    // methodsMap - block - getBlockOverview
    // methodsMap - block - getBestBlockHash
    // methodsMap - block - syncPercentage
    // methodsMap - block - isSynced
    // methodsMap - transaction - getRawTransaction
    // methodsMap - transaction - getTransaction
    // methodsMap - transaction - getDetailedTransaction
    // methodsMap - transaction - setTxMetaInfo
    // methodsMap - address - getAddressHistory
    // methodsMap - address - getAddressSummary
    // methodsMap - address - getAddressUnspentOutputs
    // methodsMap - fee - estimateFee
  });
};

/**
 * This function will gather all of the available events exposed from
 * the enabled services.
 */
WebService.prototype.getEventNames = function() {
  //this collect all publish events recursively and put them to eventNames[]
  var events = this.node.getAllPublishEvents();
  var eventNames = [];

  function addEventName(name) {
    if(eventNames.indexOf(name) > -1) {
      throw new Error('Duplicate event ' + name);
    }
    eventNames.push(name);
  }

  events.forEach(function(event) {
    addEventName(event.name);

    if(event.extraEvents) {
      event.extraEvents.forEach(function(name) {
        addEventName(name);
      });
    }
  });

  return eventNames;
};

WebService.prototype._getRemoteAddress = function(socket) {
  return socket.client.request.headers['cf-connecting-ip'] || socket.conn.remoteAddress;
};

/**
 * This function is responsible for managing a socket.io connection, including
 * instantiating a new Bus, subscribing/unsubscribing and handling RPC commands.
 * @param {Socket} socket - A socket.io socket instance
 */
WebService.prototype.socketHandler = function(socket) {
  var self = this;
  var remoteAddress = self._getRemoteAddress(socket);
  var bus = this.node.openBus({remoteAddress: remoteAddress});

  //when there is a (rpc) message, i let socketMessageHandler to handle it, see next function
  //when there is a (un)subscribe event, i (un)subscribe with bus
  if (this.enableSocketRPC) {
    socket.on('message', this.socketMessageHandler.bind(this));
  }

  //in total four lines got printed, two of them are insight-ui/public/src/js/controllers/connection.js, status.js , but what are the other two???
  //if we visit the portal using url like http://localhost:port, the remoteAddress will be ::1
  //if we visit the portal using url like http://our-lan-ip:port, the remoteAddress will be ::ffff:10.34.97.55
  socket.on('subscribe', function(name, params) {
    log.info('client with address '+remoteAddress, 'web socket subscribe:', name);
    bus.subscribe(name, params);
  });

  socket.on('unsubscribe', function(name, params) {
    log.info('client with address '+remoteAddress, 'web socket unsubscribe:', name);
    bus.unsubscribe(name, params);
  });

  this.eventNames.forEach(function(eventName) {
    bus.on(eventName, function() {
      if(socket.connected) {
        var results = [];

        //arguments is an Array-like object accessible inside functions that
        //contains the values of the arguments passed to that function
        for(var i = 0; i < arguments.length; i++) {
          results.push(arguments[i]);
        }

        //my guess is, to construct a new array, with the first element is the eventName
        //and then subsequent elements are its arguments (but how are these arguments passed? is it passed in by the bus?)
        //then emit this event (essentially in the form of a new array) to the socket.io instance
        var params = [eventName].concat(results);
        socket.emit.apply(socket, params);
      }
    });
  });

  socket.on('disconnect', function() {
    log.info(remoteAddress, 'web socket disconnect');
    //closing bus will auto unsubscribe all registered subscriptions on the same bus of the given socket (socket = the visitor on web)
    bus.close();
  });
};

/**
 * This method will handle incoming RPC messages to a socket.io connection,
 * call the appropriate method, and respond with the result.
 * @param {Object} message - The socket.io "message" object
 * @param {Function} socketCallback
 */
WebService.prototype.socketMessageHandler = function(message, socketCallback) {
  if (this.methodsMap[message.method]) {
    var params = message.params;

    if(!params || !params.length) {
      params = [];
    }

    if(params.length !== this.methodsMap[message.method].args) {
      return socketCallback({
        error: {
          message: 'Expected ' + this.methodsMap[message.method].args + ' parameter(s)'
        }
      });
    }

    //we prepare a generic callback func for all such incoming methods
    var callback = function(err, result) {
      var response = {};
      if(err) {
        response.error = {
          message: err.toString()
        };
      }

      if(result) {
        response.result = result;
      }

      socketCallback(response);
    };

    //we add callback to the end of the argument array
    params = params.concat(callback);

    //the real method invocation takes place here
    this.methodsMap[message.method].fn.apply(this, params);

  } else {
    socketCallback({
      error: {
        message: 'Method Not Found'
      }
    });
  }
};

/**
 * This method will read `key` and `cert` from disk based on `httpsOptions` and
 * replace the options with the files.
 */
WebService.prototype.transformHttpsOptions = function() {
  if(!this.httpsOptions || !this.httpsOptions.key || !this.httpsOptions.cert) {
    throw new Error('Missing https options');
  }

  this.httpsOptions = {
    key: fs.readFileSync(this.httpsOptions.key),
    cert: fs.readFileSync(this.httpsOptions.cert)
  };
};

module.exports = WebService;
