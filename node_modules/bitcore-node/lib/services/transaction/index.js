'use strict';

var BaseService = require('../../service');
var inherits = require('util').inherits;
var Encoding = require('./encoding');
var _ = require('lodash');
var async = require('async');
var assert = require('assert');
var LRU = require('lru-cache');
var log = require('../..').log;
var util = require('util');

function TransactionService(options) {
  BaseService.call(this, options);
  this._db = this.node.services.db;
  this._mempool = this.node.services.mempool;
  this._block = this.node.services.block;
  this._header = this.node.services.header;
  this._p2p = this.node.services.p2p;
  this._timestamp = this.node.services.timestamp;
  this._network = this.node.network;

  if (this._network === 'livenet') {
    this._network = 'main';
  }
  if (this._network === 'regtest') {
    this._network = 'testnet';
  }

  // caches
  this._cacheTx = LRU(1000);
}

inherits(TransactionService, BaseService);

TransactionService.dependencies = [
  'p2p',
  'db',
  'timestamp',
  'mempool',
  'block',
  'header'
];

// ---- start public function protorypes
TransactionService.prototype.getAPIMethods = function() {
  return [
    ['getRawTransaction', this, this.getRawTransaction, 1],
    ['getTransaction', this, this.getTransaction, 1],
    ['getDetailedTransaction', this, this.getDetailedTransaction, 1],
    ['setTxMetaInfo', this, this.setTxMetaInfo, 2]
  ];
};

//with the tx returned from .getTransaction(txid),
//this func further agument all the output inputs of that tx and
//set them to tx.outputs, tx.intputs accordingly
TransactionService.prototype.getDetailedTransaction = function(txid, options, callback) {

  var self = this;
  self.getTransaction(txid, options, function(err, tx) {

    if (err) {
      return callback(err);
    }

    if (!tx) {
      return callback();
    }

    //async.parallel kick off operations in parallel, usualy they are io related operations
    //as javascript remain single threaded, so the js code itself are still executed in series, io may get speeded up.
    //async.each(collection,func,callback) apply func to each item in collection in parallel, invoked with (item,keyOrIndex,callback)
    //async.each(collection,opLimit,func,callback) limits to up to 4 aysnc operations

    async.parallel([
      function(next) {
        //this function is for ONE output of the given tx
        //func(output - this output, index - index of this output, next - callback func)
        //4 calls (essentially 4 ios) are carried out in parallel
        async.eachOfLimit(tx.outputs, 4, function(output, index, next) {

          //but we have access to all variables, such txid, index of this output in the tx etc
          self._db.get(self._encoding.encodeSpentKey(txid, index), function(err, value) {
            if (err) {
              return next(err);
            }
            if (!value) {
              return next();
            }
            var spentIndex = self._encoding.decodeSpentValue(value);
            tx.outputs[index].spentTxId = spentIndex.txid;
            tx.outputs[index].spentIndex = spentIndex.inputIndex;
            tx.outputs[index].spentHeight = spentIndex.blockHeight;
            tx.outputs[index].spentBlockHash = spentIndex.blockHash;
            next();
          });
        }, next);
      },
      function(next) {
        async.eachOfLimit(tx.inputs, 4, function(input, index, next) {
          //TODO: why this is encoded with doubleSpentKey not spentKey (as for output above)
          self._db.get(self._encoding.encodeDoubleSpentKey(input.prevout.txid(), index), function(err, value) {
            if (err) {
              return next(err);
            }
            if (!value) {
              return next();
            }
            var doubleSpendInfo = self._encoding.decodeDoubleSpentValue(value);
            tx.inputs[index].doubleSpentTxID = doubleSpendInfo.txid;
            next();
          });
        }, next);
      }
    ], function(err) {
      if (err) {
        return callback(err);
      }
      callback(null, tx);
    });
  });

};

//get the tranasction by txid
//search cache, db then mempool, agumented with input/output/fee in satoshi
TransactionService.prototype.getTransaction = function(txid, options, callback) {

  var self = this;

  if (typeof callback !== 'function') {
    callback = options;
  }

  //check the cache first
  var cacheTx = self._cacheTx.get(txid);
  if (cacheTx) {
    return callback(null, cacheTx);
  }

  async.waterfall([
    self._getTransaction.bind(self, txid, options), //i.e. _getTransaction(txid,options) from db, callback with (txid,tx,options)
    self._getMempoolTransaction.bind(self),         //if not in db, we query mempool
    self.setTxMetaInfo.bind(self)                   //we populate inputSatoshis, outputSatoshis, feeSatoshis
  ], function(err, tx) {
    if (err) {
      return callback(err);
    }
    if (tx) {
      self._cacheTx.set(txid, tx);
    }
    callback(err, tx);
  });

};
//we dont check for coinbase tx, for all other non-coinbase tx, we sum all the inputs and
//calculate and store input/output/fee in satoshi. as an end result, these values are set
//tx.inputSatoshis tx.outputSatoshis, tx.feeSatoshis
TransactionService.prototype.setTxMetaInfo = function(tx, options, callback) {

  var self = this;

  if (!tx) {
    return callback();
  }

  async.waterfall([
    //find and set the output history of all the inputs of a tx
    function(next) {
      //the purpose of _getInputValues is to populate __inputValues, if it is already set, we skip
      if (tx.__inputValues) {
        return next(null, tx);
      }

      // the tx's that contain these input values could, themselves be unconfirmed
      // we are also assuming that this tx is from the mempool
      self._getInputValues(tx, options, function(err, inputValues) {

        if (err) {
          return callback(err);
        }

        //note that the output history of the inputs of this tx is set to __inputValues
        tx.__inputValues = inputValues;

        tx.confirmations = 0;
        tx.blockHash = null;
        tx.__blockHash = null;
        next(null, tx);

      });
    },
    //we sum all the output and inputs
    //coinbase tx is the exception, we dont check it
    function(tx, next) {

      // output values
      var outputSatoshis = 0;

      tx.outputs.forEach(function(output) {
        outputSatoshis += output.value;
      });

      tx.outputSatoshis = outputSatoshis;

      //input values

      if (!tx.inputs[0].isCoinbase()) {

        var inputSatoshis = 0;

        assert(tx.__inputValues.length === tx.inputs.length,
        'Transaction Service: input values length is not the same as the number of inputs.');

        tx.__inputValues.forEach(function(val) {

          if (val > 0) {
            inputSatoshis += val;
          }
        });

        var feeSatoshis = inputSatoshis - outputSatoshis;
        tx.inputSatoshis = inputSatoshis;
        tx.feeSatoshis = feeSatoshis;

      }

      next(null, tx);
    }
  ], function(err, tx) {
    if (err) {
      return callback(err);
    }
    callback(null, tx);
  });

};

TransactionService.prototype._getMempoolTransaction = function(txid, tx, options, callback) {

  var self = this;
  //options.queryMempool is a boolean value
  //by default we will query mempool
  var queryMempool = _.isUndefined(options.queryMempool) ? true : options.queryMempool;

  //we have found the tx or if we havn't found but we are instructed not to query mempool, we return immediately
  if (tx || !queryMempool) {
    return callback(null, tx, options);
  }

  //now we query mempool
  self._mempool.getMempoolTransaction(txid, function(err, tx) {

    if (err) {
      return callback(err);
    }

    if (!tx) {
      return callback(null, tx, options);
    }

    //no matter we have it in mempool, we return tx and options
    callback(null, tx, options);
  });

};

//use the encoded tx id to get data from db
TransactionService.prototype._getTransaction = function(txid, options, callback) {

  var self = this;

  // txs will be in the index, the current block at LOWER tx indexes
  // or they don't exist for the purposes of this function
  // inputValues will be on the tx already by this point.
  var currentBlockTx = options && options.processedTxs &&
    options.processedTxs[txid] ? options.processedTxs[txid] : null;

  if (currentBlockTx) {
    return setImmediate(function() {
      callback(null, txid, currentBlockTx, options);
    });
  }

  var key = self._encoding.encodeTransactionKey(txid);
  self._db.get(key, function(err, tx) {

    if (err) {
      return callback(err);
    }

    if (!tx) {
      return callback(null, txid, tx, options);
    }

    tx = self._encoding.decodeTransactionValue(tx);
    tx.confirmations = self._block.getTip().height - tx.__height + 1;
    tx.__confirmations = self._block.getTip().height - tx.__height + 1;
    tx.height = tx.__height;
    tx.blockhash = tx.__blockhash;

    callback(null, txid, tx, options);

  });

};


//this function is given the new tx (whose tx id 6000), for each and every input,
//find out the corresponding output in past tx (db+mempool), and return the consolidated outputs
TransactionService.prototype._getInputValues = function(tx, options, callback) {

  var self = this;

  var _tx = tx;

  //async.mapLimit apply func on each element in collection, in parallel, maxt at 4 at a time
  //in this case, we process each tx.input in the func below
  async.mapLimit(tx.inputs, 4, function(input, next) {

    //if it is a coinbase we skip processing
    if (input.isCoinbase()) {
      return next(null, 0);
    }

    //input.prevout.index is the index of the corresponding output in that past tx to be used as input in our tx.
    //for example in txid=5000, output index 3 there is a output value = 1btc,
    //now in txid=6000, we want to use that output as our input, so in this new tx we will have
    // - input.prevout.index = 3
    // - input.prevout.txid = 5000

    //this output index of past tx will be useful later
    var outputIndex = input.prevout.index;

    //the waterfall is consist of several steps
    // - we try to get past tx transaction from db
    // - if not found, we check mempool
    // - if still not found, then we can't do much, we just return an error
    // - if we found either in db or mempool, we set output and return output.value (end of the inner mapLimt func)
    //aysnc.mapLimit will consolidate all such output returned data for each input of the given tx, order is preserved
    async.waterfall([
      // check tx index first, most likely place
      function(next) {
        self._getTransaction(input.prevout.txid(), options, next);
      },
      // if not there, then check mempool
      function(txid, tx, options, next) {
        //if we already found tx in _getTransaction() we skip this func
        if (tx) {
          return next(null, txid, tx);
        }
        self._mempool.getMempoolTransaction(input.prevout.txid(), function(err, memTx) {
          if (err) {
            return next(err);
          }
          next(null, txid, memTx);
        });
      },
      // if not in mempool or tx index, we just don't have it, yet?
      function(txid, tx, next) {
        if (!tx) {
          return next(new Error('Transaction Service: prev transacion: (' + input.prevout.txid() + ') for tx: ' +
            _tx.txid() + ' at input index: ' + outputIndex + ' is missing from the index or not in the memory pool. It could  be' +
            ' that the parent tx has not yet been relayed to us, but will be relayed in the near future.'));
        }
        var output = tx.outputs[outputIndex];

        assert(output, 'Expected an output, but did not get one for tx: ' + tx.txid() + ' outputIndex: ' + outputIndex);

        next(null, output.value);
      }
    ], function(err, val) {
      if (err) {
        return next(err);
      }
      next(null, val);
    });
  }, callback);

};

TransactionService.prototype.start = function(callback) {

  var self = this;

  self._db.getPrefix(self.name, function(err, prefix) {

    if(err) {
      return callback(err);
    }

    self.prefix = prefix;
    self._encoding = new Encoding(self.prefix);
    callback();

  });
};

TransactionService.prototype.stop = function(callback) {
  setImmediate(callback);
};

// --- start private prototype functions
TransactionService.prototype._getBlockTimestamp = function(hash) {
  return this._timestamp.getTimestampSync(hash);
};

//when this service receives a new block
//for each tx in this block, we call _processTrnasaction
//recall block services call .onBlock() for all services in the same node,
//so the (db) operations that we callback will go back to the block service and get applied there
TransactionService.prototype.onBlock = function(block, callback) {

  var self = this;
  var processedTxs = {};

  if (self.node.stopping) {
    return callback();
  }

  async.mapSeries(block.txs, function(tx, next) {

    processedTxs[tx.txid()] = tx;
    self._processTransaction(tx, { block: block, processedTxs: processedTxs }, next);

  }, function(err, operations) {

    if (err) {
      return callback(err);
    }

    assert(block.txs.length === operations.length, 'It seems we are not indexing the correct number of transactions.');

    var testrunNewOps = _.compact(_.flattenDeep(operations));
    log.info('transaction service .onBlock returning: '+util.inspect(testrunNewOps));
    log.info('the transaction returned ops count is '+testrunNewOps.length);
    callback(null, _.flattenDeep(operations));
  });

};

TransactionService.prototype.onReorg = function(args, callback) {

  var self = this;

  var oldBlockList = args[1];

  var removalOps = [];

  // remove the txid -> tx entries
  // remove the prevTxid, outputIndex -> txid, inputIndex
  for(var i = 0; i < oldBlockList.length; i++) {

    var block = oldBlockList[i];

    for(var j = 0; j < block.txs.length; j++) {

      var tx = block.txs[j];

      removalOps.push({
        type: 'del',
        key: self._encoding.encodeTransactionKey(tx.txid())
      });

      // remove all the spent index information
      for(var k = 0; k < tx.inputs.length; k++) {
        var input = tx.inputs[k];
        removalOps.push({
          type: 'del',
          key: self._encoding.encodeSpentKey(input.prevout.txid(), input.prevout.index)
        });
      }

    }
  }

  setImmediate(function() {
    callback(null, removalOps);
  });

};

//get the spent info from the db
TransactionService.prototype._getSpentInfo = function(input, callback) {
  if (!this.node.stopping) {
    return this._db.get(this._encoding.encodeSpentKey(input.prevout.txid(), input.prevout.index), callback);
  }
  callback();
};

//for this tx, we search all the inputs
//for each input, together with the index, we either save it as spent, or double spent to db.
//note that no tx.outputs are processed
TransactionService.prototype._getSpentTxOperations = function(tx, callback) {
  var self = this;

  var ops = [];
  // if any of this tx's inputs are double spending, then make an entry into this index.
  async.eachOfLimit(tx.inputs, 4, function(input, index, next) {

    self._getSpentInfo(input, function(err, info) {

      if (err) {
        return callback(err);
      }

      //if we found the past spent history, then we will mark it double spent
      if (info) {
        ops.push({
          key: self._encoding.encodeDoubleSpentKey(input.prevout.txid(), input.prevout.index),
          value: self._encoding.encodeDoubleSpentValue(tx.txid(), index, tx.__height, tx.__blockhash)
        });
        return next();
      }

      //if we didn't find the past spent history, we save to the spent history
      ops.push({
        key: self._encoding.encodeSpentKey(input.prevout.txid(), input.prevout.index),
        value: self._encoding.encodeSpentValue(tx.txid(), index, tx.__height, tx.__blockhash)
      });
      next();

    });
  }, function(err) {
    if (err) {
      return callback(err);
    }
    callback(null, ops);

  });
};

//this func is to process one single tx
//the opts has this structure { block: blockWhereThisTxIsIn, processedTxs[txKey]=tx }
TransactionService.prototype._processTransaction = function(tx, opts, callback) {

  var self = this;

  //first we _getInputValues for the tx, which is passed to inputValues in the callback func
  //the callback set __inputValues, __timestamp, __height, __blockhash
  self._getInputValues(tx, opts, function(err, inputValues) {

    if (err) {
      return callback(err);
    }

    assert(inputValues && inputValues.length === tx.inputs.length,
      'Input values missing from tx.');

    // inputValues
    tx.__inputValues = inputValues;

    // timestamp
    tx.__timestamp = self._getBlockTimestamp(opts.block.rhash());
    assert(tx.__timestamp, 'Timestamp is required when saving a transaction.');

    // height
    tx.__height = opts.block.__height;
    assert(tx.__height, 'Block height is required when saving a trasnaction.');

    // block hash
    tx.__blockhash = opts.block.rhash();

    //we first want to save tx data,
    var operations = [{
      key: self._encoding.encodeTransactionKey(tx.txid()),
      value: self._encoding.encodeTransactionValue(tx)
    }];

    //then we go down to each input of this tx, save the low level data
    //why no output?? my understanding is when future tx refer to this block's output, we will work on it then
    //that means we only care about the consistency of current+past data, where are the $ gone is not really a big deal

    //developer's comment
    // spent key and value
    // for each input in this tx, it spend some tx's prev outs, so index those
    // this also accounts for double spend operations
    self._getSpentTxOperations(tx, function(err, ops) {

      if (err) {
        return callback(err);
      }

      //concat all the db operations and return
      operations = operations.concat(ops);
      callback(null, operations);

    });

  });

};

module.exports = TransactionService;
