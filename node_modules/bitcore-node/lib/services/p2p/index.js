'use strict';

var p2p = require('bitcore-p2p');
var LRU = require('lru-cache');
var util = require('util');
var index = require('../../');
var log = index.log;
var BaseService = require('../../service');
var assert = require('assert');
var Bcoin = require('./bcoin');
var BcoinTx = require('bcoin').tx;
var Networks = require('bitcore-lib').Networks;
var LRU = require('lru-cache');

//constructor
var P2P = function(options) {

  if (!(this instanceof P2P)) {
    return new P2P(options);
  }

  BaseService.call(this, options);
  //the options are what we define in the 'peers' block of bitcore-node.json
  this._options = options;

  //here we pass config defined in bitcore-node.json to this module, and init other data structures
  this._initP2P();
  this._initPubSub();

  this._bcoin = null;
  this._currentBestHeight = null;
  this._latestBits = 0x1d00ffff;
  this._outgoingTxs = LRU(100); // these are outgoing txs that are awaiting getdata messages
  //this is a block cache managed by LRU-cache library
  //where cache allows set(), get(), peek(), del() etc
  this._blockCache = options.blockCacheCount || LRU({
    max: 10,
    maxAge: 1000 * 60 * 5}); // keep this modest to avoid memory dumps [hash -> block]

};

util.inherits(P2P, BaseService);

P2P.dependencies = [];

P2P.prototype.clearInventoryCache = function() {
  this._inv.reset();
};

//the exposed api methods
//these methods are called by modules like header, mempool, block, address etc
//e.g. in block module, line 1130+, self._p2p.getP2PBlock({...})
//this is how this method is called by others
P2P.prototype.getAPIMethods = function() {
  var methods = [
    ['clearInventoryCache', this, this.clearInventoryCache, 0],
    ['getP2PBlock', this, this.getP2PBlock, 1],
    ['getHeaders', this, this.getHeaders, 1],
    ['getMempool', this, this.getMempool, 0],
    ['sendTransaction', this, this.sendTransaction, 1]
  ];
  return methods;
};

P2P.prototype.getNumberOfPeers = function() {
  return this._pool.numberConnected;
};

//p2p module get a getP2PBlock call, we in turn talk to our peer to get the blocks
//the calling module only want one block (represented by opts.blockHash),
//but we prefetch a small range of blocks from our peer (which usually is 2 blocks)
//that particular block wanted, is either cached, or will be fetched from peer
//either way, callback() will be called, with the block as the only argument
P2P.prototype.getP2PBlock = function(opts, callback) {

  // opts is { filter: {<start and end hashes>}, blockHash: block hash we want }

  var self = this;

  // do we already have this block in our cache?
  var block = self._blockCache.get(opts.blockHash);

  //if yes, we callback the caller and pass it our block in cache
  if (block) {
    return callback(block);
  }

  //get the 'best' peer with max known height
  var peer = self._getPeer();

  var blockFilter = self._setResourceFilter(opts.filter, 'blocks');

  //if after 5seconds, nothing happen, then we deregister that once-event named opts.blockHash

  //developer's comment (which i dont quite understand actually)
  // there is a possibility that the main chain has reorganized after we last
  // computed our expected block and before our peer computes what block to
  // send us in response.
  // In self case, we want to abandon self block and remove its listener.
  // Our caller should also reset its expectations and re-compute its expected
  // block and call us again.
  // If we are wrong about the reorg, then the peer is just really slow and we ought
  // to use self peer anyway.
  setTimeout(function() {
    self.removeListener(opts.blockHash, callback);
  }, 5000);

  //.once() func is provided by Emitter, it register a event using opts.blockHash as name, and gurantee the listener (2nd param)
  //is called at most once for this event.
  self.once(opts.blockHash, callback);

  //TODO-low: where is the GetBlocks data structure defined?
  //we talk to our 'best' peer and send a GetBlocks message request which is, by bitcoin protocol, used to get block data from the peer
  peer.sendMessage(self.messages.GetBlocks(blockFilter));
};

//p2p module get a getHeaders call, we in turn talk to our peer to get the headers
P2P.prototype.getHeaders = function(filter) {
  var peer = this._getPeer();
  var headerFilter = this._setResourceFilter(filter, 'headers');
  //we talk to our 'best' peer and send a GetHeaders message request, to get headers from the peer
  peer.sendMessage(this.messages.GetHeaders(headerFilter));

};

//p2p module get a getMempool call, we in turn talk to our peer to get the mempool
P2P.prototype.getMempool = function() {
  var peer = this._getPeer();
  //we talk to our 'best' peer and send a MemPool message request, to get mempool data from the peer
  peer.sendMessage(this.messages.MemPool());
};

//these are three events that p2p service will publish
//this event data structure, as well as the outer array (array of event) is used by bus module, at Bus.prototype.subscribe
//the scope is a reference back to this instance, meaning when someone subscribe for my event e.g. p2p/block, use event.scope to notify me
P2P.prototype.getPublishEvents = function() {
  return [
    {
      name: 'p2p/transaction',
      scope: this,
      subscribe: this.subscribe.bind(this, 'transaction'),
      unsubscribe: this.unsubscribe.bind(this, 'transaction')
    },
    {
      name: 'p2p/block',
      scope: this,
      subscribe: this.subscribe.bind(this, 'block'),
      unsubscribe: this.unsubscribe.bind(this, 'block')
    },
    {
      name: 'p2p/headers',
      scope: this,
      subscribe: this.subscribe.bind(this, 'headers'),
      unsubscribe: this.unsubscribe.bind(this, 'headers')
    }
  ];
};

//use the peer to post our transaction to the global p2p network
P2P.prototype.sendTransaction = function(tx, callback) {
  var peer = this._getPeer();

  var bcoinTx;
  try {
    bcoinTx = BcoinTx.fromRaw(tx, 'hex');
  } catch(e) {
    return callback(e);
  }

  log.info('P2P Service: sending transaction: ' + bcoinTx.txid());

  this._outgoingTxs.set(bcoinTx.txid(), bcoinTx);
  var inv = p2p.Inventory.forTransaction(bcoinTx.txid());
  var txMessage = this.messages.Inventory([inv]);

  //we post our tx to our 'best' peer
  peer.sendMessage(txMessage);

  this._onPeerTx(peer, { transaction: bcoinTx });

  return callback(null, bcoinTx.txid());
};

//look at the code, the steps are
// - start the built-in bcoin node if necessary (if we define any peer in config, bcoin will be skipped)
// - [at this step, either a peer or a bcoin node is ready]
// - the callback function that defined here will be called from within _startBCoinIfNecessary()
// - initialize cache and pool
// - we register all listeners to prepare for future events
P2P.prototype.start = function(callback) {
  var self = this;
  self._startBcoinIfNecessary(function(){
    self._initCache();
    self._initPool();
    self._setListeners();
    callback();
  });
};

P2P.prototype._disconnectPool = function() {

  log.info('P2P Service: disconnecting pool and peers. SIGINT issued, system shutdown initiated');
  this._pool.disconnect();

};

P2P.prototype.stop = function(callback) {

  if (this._bcoin){
    return this._bcoin.stop(callback);
  }

  setImmediate(callback);
};

//the business scenario is, header module subscribes to p2p module for block event
//sample log output: localhost-header subscribe: p2p/block total: 1
//so in this case,
// - name = 'block'
// - emitter = a bus instance which represents the subscriber,
//             bus { remoteAddress: 'localhost-header', node: Node {...}, _events: { 'p2p/headers': [Function: bound ], 'p2p/block': [Function: bound ] } } where _events store all subscribed events (including this event) request from header
P2P.prototype.subscribe = function(name, emitter) {
  //this.subscriptions is a map with eventname (without 'p2p') -> list_of_emitter
  //e.g. p2p.subscritpions[headers] = [ emitter1, emitter2 ...]
  //     p2p.subscriptions[block] = [ emitter1, emitter3 ... ]
  //so that
  //when p2p module get a new block from its peer network, i.e. _onPeerBlock triggered, this._broadcast() will be called    this._broadcast(this.subscriptions.block, 'p2p/block', message.block);
  //when p2p module get a new header from its peer network, i.e. _onPeerHeaders triggered, this._broadcast() will be called this._broadcast(this.subscriptions.headers, 'p2p/headers', message.headers);
  this.subscriptions[name].push(emitter);
  //emitter.remoteAddress is the subscriber, the actual value is localhost-header
  log.info(emitter.remoteAddress, 'subscribe:', 'p2p/' + name, 'total:', this.subscriptions[name].length);
};

//sample log output: localhost-header unsubscribe: p2p/headers total: 0
//note the 0 means, there is no more subscription from headers (name) to p2p
P2P.prototype.unsubscribe = function(name, emitter) {
  var index = this.subscriptions[name].indexOf(emitter);
  if (index > -1) {
    this.subscriptions[name].splice(index, 1);
  }
  log.info(emitter.remoteAddress, 'unsubscribe:', 'p2p/' + name, 'total:', this.subscriptions[name].length);
};


// --- privates

P2P.prototype._addPeer = function(peer) {
  this._peers.push(peer);
};

P2P.prototype._applyMempoolFilter = function(message) {
  if (!this._mempoolFilter) {
    return message;
  }
  var txIndex = this._mempoolFilter.indexOf(message.transaction.hash);
  if (txIndex >= 0) {
    this._mempoolFilter.splice(txIndex, 1);
    return;
  }
  return message;
};

//we send a event message (with event name) with data (entity) to all subscribers for this particular event
//event name will be checked by the reciever (subscriber)
//event data will be parsed and processed subsequently
//technically subscribers[i] is actually a bus instance that on 1-1 relationship with the subscriber
//we emit a message through the subscriber's bus, their bus have registered message handlers to deal with this message
//one of p2p subscriber is header module, in header/index.js, line 580+, we have code
//  HeaderService.prototype._startBlockSubscription { ... this._bus.on('p2p/block', this._queueBlock.bind(this)); ... }
//  this is how the message handler is registered
//when we call headerBus.emit(name,entity) here, tha header's _queueBlock is invoked
P2P.prototype._broadcast = function(subscribers, name, entity) {
  for (var i = 0; i < subscribers.length; i++) {
    subscribers[i].emit(name, entity);
  }
};

P2P.prototype._setRetryInterval = function() {
  var self = this;
  if (!self._retryInterval && !self.node.stopping) {

    self._retryInterval = setInterval(function() {
      log.info('Retrying connection to p2p network.');
      self._pool.connect();
    }, 5000);

  }
};

P2P.prototype._connect = function() {

  var self = this;

  log.info('Connecting to p2p network.');
  self._pool.connect();

  self._setRetryInterval();

};

P2P.prototype._getBestHeight = function() {

  if (this._peers === 0) {
    return 0;
  }

  var maxHeight = -1;
  for(var i = 0; i < this._peers.length; i++) {
    if (this._peers[i].bestHeight > maxHeight) {
      maxHeight = this._peers[i].bestHeight;
      //the peer with max bestHeight will be set as the 'default go-to-peer' _peer
      this._peer = this._peers[i];
    }
  }
  return maxHeight;
};

// we should only choose from a list of peers that sync'ed
P2P.prototype._getPeer = function() {
  return this._peer;
};

P2P.prototype._hasPeers = function() {
  return this._options &&
    this._options.peers &&
    this._options.peers.length > 0;
};

P2P.prototype._initCache = function() {
  this._inv = LRU(1000);
};

P2P.prototype._initP2P = function() {
  this._maxPeers = this._options.maxPeers || 60;
  this._minPeers = this._options.minPeers || 0;
  //now _configPeers are what we define in 'peers' in bitcore-node.json
  this._configPeers = this._options.peers;

  if (this.node.network === 'regtest') {
    Networks.enableRegtest();
  }
  //for p2p.Messages, refer to bitcore-p2p/lib/messages/index.js which exposes Messages
  //here we specify our messages are for a particular network (either livenet/testnet), later this.messages will be referenced in many other places
  this.messages = new p2p.Messages({ network: Networks.get(this.node.network), Transaction: BcoinTx });
  this._peerHeights = [];
  this._peers = [];
  this._peerIndex = 0;
  this._mempoolFilter = [];
};

//we construct a new data structure opts and pass it to the p2p.Pool constructor
//p2p.Pool implementation can be found in bitcore-p2p/lib/pool.js
//constructor's core parameters
// - addrs = all peers defined in bitcore-node.json
// - network = livenet or testnet
//at the end of this function, a _pool is ready
P2P.prototype._initPool = function() {
  var opts = {};
  if (this._configPeers) {
    opts.addrs = this._configPeers;
  }
  opts.dnsSeed = false;
  opts.listenAddr = false;
  opts.maxPeers = this._maxPeers;
  opts.network = this.node.network;
  p2p.Pool.RetrySeconds = 3;
  this._pool = new p2p.Pool(opts);
};

P2P.prototype._initPubSub = function() {
  this.subscriptions = {};
  //we have no subscribers now
  this.subscriptions.block = [];
  this.subscriptions.headers = [];
  this.subscriptions.transaction = [];
};

//look at line 500+, self._pool.on('peerblock', self._onPeerBlock.bind(self));
//when _pool has an 'peerblock' event, this _onPeerBlock is called
P2P.prototype._onPeerBlock = function(peer, message) {
  //add this block to cache
  this._blockCache.set(message.block.rhash(), message.block);
  //TODO: this emit to who? where can i find the handler? seems it is not handled anywhere?
  this.emit(message.block.rhash(), message.block);
  //broadcast to all subscribers
  //this.subscriptions.block is equivalent to this.subscriptions[block]
  this._broadcast(this.subscriptions.block, 'p2p/block', message.block);
};

P2P.prototype._onPeerDisconnect = function(peer, addr) {

  this._removePeer(peer);

  if (this._peers.length < 1) {
    this._setRetryInterval();
  }

  log.info('Disconnected from peer: ' + addr.ip.v4);

};

//according to https://bitcore.io/api/p2p/messages
//getData is to retrieve the content of a specific object after receiving an inventory packet, after filtering known elements
//here it is a onPeerGetData event, meaning some peer ask us to send data to them
P2P.prototype._onPeerGetData = function(peer, message) {
  // we can only respond to tx messages
  var txId  = message.inventory[0].hash.reverse().toString('hex');
  //we search in outgoingTx, if found, we send data over
  var tx = this._outgoingTxs.get(txId);
  if (tx) {
    //we reply to the peer with the specific data that it wants
    peer.sendMessage(this.messages.Transaction(tx, { Transaction: BcoinTx }));
  }
};

P2P.prototype._onPeerHeaders = function(peer, message) {
  //this.subscriptions.headers is equivalent to this.subscriptions[headers]
  this._broadcast(this.subscriptions.headers, 'p2p/headers', message.headers);
};

//TODO-low: to read through in detailed
//according to https://bitcore.io/api/p2p/messages
//inventory event is some peer announce that it has some new for me to discover
//so I go through my own inventory _inv,
//if the inventory in the incoming message is not found in my _inv
//i add them to newDataNeeded
//and then try to getData from this peer
P2P.prototype._onPeerInventory = function(peer, message) {

  var self = this;
  var newDataNeeded = [];
  message.inventory.forEach(function(inv) {
    //my guess is : it seems if a hash is in _inv, this p2p module has sent the block out previously,
    //and therefore wont take the effort to work on it again.
    if (!self._inv.get(inv.hash)) {
      self._inv.set(inv.hash, true);
      newDataNeeded.push(inv);
    }
  });

  if (newDataNeeded.length > 0) {
    //send a GetData message to the peer who send us "inventory" message to get those data that are not found in our _inv
    //messages.GetData
    peer.sendMessage(self.messages.GetData(newDataNeeded));
  }
};

P2P.prototype._matchNetwork = function(network) {

  if (this.node.network !== network.name &&
    this.node.network !== network.alias) {
    log.error('Configured network: "' + this.node.network +
      '" does not match our peer\'s reported network: "' +
      network.name + '".');
    //if it doesnot match, we stop the node
    return this.node.stop();
  }

  return this.node.network === network.name ? network.name : network.alias;

};

//when peer(s) are ready, we compute the best height and emit a bestHeight event
//header module who subscribe for this event will get notified. It will _startSync()
P2P.prototype._onPeerReady = function(peer, addr) {

  // clear any interval timers that we previously set
  if (this._retryInterval) {
    clearInterval(this._retryInterval);
    this._retryInterval = null;
  }

  //network means livenet, testnet etc, of course we can't connect to a livenet to sync our testnet, or vice versa
  var network = this._matchNetwork(peer.network);

  if (!network) {
    return;
  }

  //sample log output: Connected to peer: 127.0.0.1, network: livenet, version: 70015, subversion: /Satoshi:0.16.0/, status: ready, port: 8333, best height: 547361
  log.info('Connected to peer: ' + addr.ip.v4 + ', network: ' +
    network + ', version: ' + peer.version + ', subversion: ' +
      peer.subversion + ', status: ' + peer.status + ', port: ' +
      peer.port + ', best height: ' + peer.bestHeight);

  //we register this peer to our peer list
  this._addPeer(peer);
  //we recheck the best height among all peers, if there is a better bestHeight, the return value will be >=0
  //in that case, we emit a 'bestHeight' event
  //the header module is listening on this event, will consume the data accordingly
  var bestHeight = this._getBestHeight();

  //header/index.js line 660+ has code to consume this bestHeight event
  //this._p2p.on('bestHeight', this._onBestHeight.bind(this));
  if (bestHeight >= 0) {
    this.emit('bestHeight', bestHeight);
  }

};

//when we hear a new tx from our peers, we broadcast to our subscription list (ie we relay the tx to our internal services)
P2P.prototype._onPeerTx = function(peer, message) {
  //this.subscriptions.transaction is equivalent to this.subscriptions[transaction]
  this._broadcast(this.subscriptions.transaction, 'p2p/transaction', message.transaction);
};

//we remove this peer (splice is a func to add/remove elements to/from an array)
P2P.prototype._removePeer = function(peer) {
  this._peers.splice(this._peers.indexOf(peer), 1);
};

//register all private handlers for events from _pool
//when node is ready, connect to _pool
//when node is stopping, disconnect from _pool
//when there is a new peer ready, we register this peer and recheck best height
//when there is a peer disconnected, we remove it from our peer list
//when there is a peer new inventory event, we check if we have all the inventory, if not we ask for those missing ones from the same peer
//when there is a transaction from our peer, we broadcast to our subscribers (by publishing a 'p2p/transaction' event)
//when there is a block from our peer, we broadcast to our subscribers (by publishing a 'p2p/block' event)
//when there is a header from our peer, we broadcast to our subscribers (by publishing a 'p2p/headers' event)
P2P.prototype._setListeners = function() {
  var self = this;
  self.node.on('stopping', self._disconnectPool.bind(self));
  //now we register _onPeerReady for a peerready event
  //on runtime, when the _pool reports (i.e. callback) a 'peer is ready', the instance (self) will automatically invoke _onPeerReady()
  //_pool is bitcore-p2p/lib/pool.js refer to that module for detailed pool implementation
  self._pool.on('peerready', self._onPeerReady.bind(self));
  self._pool.on('peerdisconnect', self._onPeerDisconnect.bind(self));
  self._pool.on('peerinv', self._onPeerInventory.bind(self));
  self._pool.on('peertx', self._onPeerTx.bind(self));
  self._pool.on('peerblock', self._onPeerBlock.bind(self));
  self._pool.on('peerheaders', self._onPeerHeaders.bind(self));
  self._pool.on('peergetdata', self._onPeerGetData.bind(self));
  self.node.on('ready', self._connect.bind(self));
};

P2P.prototype._setResourceFilter = function(filter) {

  assert(filter && filter.startHash, 'A "startHash" field is required to retrieve headers or blocks');
  if (!filter.endHash) {
    filter.endHash = 0;
  }
  return { starts: [filter.startHash], stop: filter.endHash };

};

//if any 'peer' is defined in config json file, that means the bcoin the bulit-in bitcoin client dont need to be started
P2P.prototype._startBcoin = function(callback) {

  var self = this;

  var network;
  var port;
  if (['livenet', 'live', 'main', 'mainnet'].indexOf(this.node.network) !== -1) {
    network = 'main';
    port = this._configPeers[0].port || 8333;
  } else if (this.node.network !== 'regtest') {
    network = 'testnet';
    port = this._configPeers[0].port || 18333;
  } else {
    network = this.node.network;
    port = this._configPeers[0].port || 48444;
  }

  self._bcoin = new Bcoin({
    network: network,
    prefix: self.node.datadir,
    port: port
  });

  self._bcoin.start(callback);

};

P2P.prototype._startBcoinIfNecessary = function(callback) {
  if (!this._hasPeers()) {
    log.info('p2p service _startBcoinIfNecessary peers not explicitly configured, starting a local bcoin node.');
    this._configPeers = [{ ip: { v4: '127.0.0.1'} }];
    return this._startBcoin(callback);
  } else {
    log.info('p2p service peers defined, p2p _startBcoin() wont be called');
  }
  setImmediate(callback);
};

module.exports = P2P;
