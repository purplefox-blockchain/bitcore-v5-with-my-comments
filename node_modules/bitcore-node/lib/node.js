'use strict';

var util = require('util');
var EventEmitter = require('events').EventEmitter;
var async = require('async');
var assert = require('assert');
var bitcore = require('bitcore-lib');
var _ = bitcore.deps._;
var index = require('./');
var log = index.log;
var Bus = require('./bus');
var errors = require('./errors');

function Node(config) {

  if(!(this instanceof Node)) {
    return new Node(config);
  }

  this._init(config);

  if (!_.isUndefined(config.formatLogs)) {
    this.log.formatting = config.formatLogs ? true : false;
  }

  if (config.services) {
    this._unloadedServices = config.services;
  }
}

util.inherits(Node, EventEmitter);

Node.prototype._init = function(config) {

  log.info('node.js _init() starts');

  this.configPath = config.path;
  this.errors = errors;
  this.log = log;

  this.datadir = config.datadir;
  this.network = null;
  this.services = {};
  this._unloadedServices = [];

  this.port = config.port;
  this.https = config.https;
  this.httpsOptions = config.httpsOptions;
  this._setNetwork(config);
};

Node.prototype._setNetwork = function(config) {
  this.network = config.network;
};

Node.prototype.openBus = function(options) {
  if (!options) {
    options = {};
  }
  return new Bus({node: this, remoteAddress: options.remoteAddress});
};

Node.prototype.getAllAPIMethods = function() {
  var methods = [];
  for(var i in this.services) {
    var mod = this.services[i];
    if (mod.getAPIMethods) {
      methods = methods.concat(mod.getAPIMethods());
    }
  }
  return methods;
};

Node.prototype.getAllPublishEvents = function() {
  var events = [];
  for (var i in this.services) {
    var mod = this.services[i];
    if (mod.getPublishEvents) {
      events = events.concat(mod.getPublishEvents());
    }
  }
  return events;
};

Node.prototype._getServiceOrder = function(services) {

  var names = [];
  var servicesByName = {};
  for (var i = 0; i < services.length; i++) {
    var service = services[i];
    names.push(service.name);
    servicesByName[service.name] = service;
  }

  var stackNames = {};
  var stack = [];

  //add all services and their dependencies to the stack by deep-first-search order
  //stack[] is the final array of all dependencies flatten, stackNames[] is the final map of the same data
  function addToStack(names) {
    for(var i = 0; i < names.length; i++) {

      var name = names[i];
      var service = servicesByName[name];
      log.info('YCM addToStack ' + name);
      assert(service, 'Required dependency "' + name + '" not available.');

      //take header/index.js for example, we have this line
      //HeaderService.dependencies = [ 'p2p', 'db' ];
      //where HeaderService is the constructor for the header service
      //here by using service.module.dependencies,
      //addToStack() will add p2p and db services to the stack first
      //so that they will be started earlier than header service too
      addToStack(service.module.dependencies);

      if(!stackNames[name]) {
        stack.push(service);
        stackNames[name] = true;
      }

    }
  }

  addToStack(names);

  return stack;
};

//serviceInfo is just a temp data holder to be used for service instance creation in this function
//it has the following format:
//name: xxx,
//module: serviceConstructor
//config: {} //options to pass to constructor
//the end result of this function call is:
// - this.services is a map of services
// - the actual service instance is added to this map
// - usage: services.#YourServiceName#.#Method# to invoke the method of the specified service
// - one thing to take note is, the newly service instance has a reference to 'this node', therefore knows the 'bigger' picture
Node.prototype._startService = function(serviceInfo, callback) {
  var self = this;

  log.info('Starting ' + serviceInfo.name);

  var config;
  if (serviceInfo.config) {
    assert(_.isObject(serviceInfo.config));
    assert(!serviceInfo.config.node);
    assert(!serviceInfo.config.name);
    config = serviceInfo.config;
  } else {
    config = {};
  }

  //we pass this node instance to all services, so that for db/p2p/mempool/etc instances,
  //they can do 'this.node.network' to know it is for livenet or testnet
  config.node = this;
  //this is just the dependencies name such as db, timestamp, p2p, header, mempool, block
  //transaction, address, fee, web, insight-api, insight-ui
  config.name = serviceInfo.name;
  //i am not sure about this line, isn't the service = config here? which is the actual instance who will serve others?
  //.module() is the constructor of the service, config is the options that are passed to the constructor
  //by doing so, we create a new service instance named 'service'
  //which is then registered to thisNode.services map
  var service = new serviceInfo.module(config);

  self.services[serviceInfo.name] = service;

  //service.start(callbackFunction) actually START the given service
  //and provide a callback function to perform some post-start works
  service.start(function(err) {
    if (err) {
      return callback(err);
    }

    //this chunk of code makes the methods defined in the function getAPIMethods() of each module become the real methods
    //that can be invoked by module.methodName(...)
    //for example, p2p module (p2p/index.js) defines the following api methods
    //P2P.prototype.getAPIMethods = function() { var methods = [ ..., ['getP2PBlock', this, this.getP2PBlock, 1], ... ]
    //and the block module (block/index.js) has these code,
    // - this._p2p = this.node.services.p2p;
    // - self._p2p.getP2PBlock( ... )
    //first line to get the p2p reference, second line to invoke the getP2PBlock on p2p reference
    if (service.getAPIMethods) {
      var methodData = service.getAPIMethods();
      var methodNameConflicts = [];
      methodData.forEach(function(data) {
        var name = data[0];
        var instance = data[1];
        var method = data[2];

        if (self[name]) {
          methodNameConflicts.push(name);
        } else {
          self[name] = function() {
            return method.apply(instance, arguments);
          };
        }
      });

      if (methodNameConflicts.length > 0) {
        return callback(new Error('Existing API method(s) exists: ' + methodNameConflicts.join(', ')));
      }
    }

    callback();

  });

};

Node.prototype._logTitle = function() {
  if (this.configPath) {
    log.info('Using config:', this.configPath);
    log.info('Using network:', this.network);
  }
};

//when node start, it call _startService, which loop through all services, call serviceXXX.start()
Node.prototype.start = function(callback) {

  log.info('node.js .start() starts');

  var self = this;

  var services = this._unloadedServices;

  var servicesOrder = this._getServiceOrder(services);

  self._logTitle();

  async.eachSeries(
    servicesOrder,
    function(service, next) {
      self._startService(service, next);
    },
    function(err) {

      if (err) {
        return callback(err);
      }

      self.emit('ready');
      callback();
    }
  );
};

Node.prototype.stop = function(callback) {

  log.info('Beginning shutdown');
  var self = this;
  //for stopping, we want to stop services in the reverses order, db service is the last one to stop
  var services = this._getServiceOrder(this._unloadedServices).reverse();

  this.stopping = true;
  this.emit('stopping');

  //for each service, one by one, we call their .stop()
  //most services' .stop() does nothing
  //p2p service stop() stop the built-in bcoin (bitpay's bitcoind implementation)
  //but if we are using external independent bitcoind, p2p stop() will not stop those daemons
  //db service stop() set _stopping flag to true, and stop all subsequent db (io) operations
  async.eachSeries(

   services,
   function(service, next) {
     if (self.services[service.name]) {
       log.info('Stopping ' + service.name);
       self.services[service.name].stop(next);
     } else {
       log.info('Stopping ' + service.name + ' (not started)');
       setImmediate(next);
     }
   },
   function() {
     if (callback) {
       callback();
     }
  });
};

module.exports = Node;
